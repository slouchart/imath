<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>pyimath.polynomial API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyimath.polynomial</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Iterable, Optional, Dict, Collection, Tuple, Sequence, Iterator, Any
import operator
from collections import namedtuple
from enum import Enum
from re import finditer


from pyimath.annotations import BaseField, BaseNumber, Operand
from pyimath.functions import gcd, rgcd, power


__all__ = [&#39;Polynomial&#39;, &#39;symbolic_polynomial&#39;]


class Polynomial:
    &#34;&#34;&#34;Represents a polynomial over a finite field or over the integers
    More generally, definition of polynomials over a ring is possible
    but not recommended
    The internal representation of the coefficients uses a dict that
    indexes the coefficients by their degree
    The usual definition of a polynomial as a sequence of numbers
    that are all zeroes from a certain index is used to initialize the polynomial
    on instantiation and can be retrieved through the coefficients property
    Moreover this class implements all the operations over a ring of polynomials

    base_field must represent an integral domain that is:
       a set which is an abelian group for + and a semi-group
       for * and where GCD are computable.
       A ring of polynomials is at least defined over an integral domain
       examples: Z, Z(i)
    &#34;&#34;&#34;

    def __init__(self, coeffs: Sequence[BaseNumber], base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;):
        &#34;&#34;&#34;
        :param coeffs: an iterable of elements from the base field
        :param base_field: an instance generally a finite field
        :param indeterminate: a single digit string used to format the polynomial
        &#34;&#34;&#34;
        self.base_field = base_field
        assert hasattr(base_field, &#39;element&#39;) and hasattr(base_field, &#39;__call__&#39;)

        self._coefficients = self._safe_convert_coefficients(self._remove_trailing_zeros(coeffs))
        self.indeterminate = indeterminate

    def _safe_convert_coefficients(self, seq: Iterable) -&gt; Dict[int, BaseNumber]:
        bf = self.base_field
        return dict({deg: bf.element(c) for deg, c in enumerate(seq) if c != bf.zero})

    def _remove_trailing_zeros(self, seq: Sequence) -&gt; Collection:
        if len(seq) == 0:
            return []
        revseq = list(reversed(seq))
        while revseq[0] == self.base_field.zero:
            revseq = revseq[1:]
            if len(revseq) == 0:
                return []

        return list(reversed(revseq))

    def set_term(self, deg: int, c: BaseNumber):
        if c == self.base_field.zero:
            if deg in self._coefficients.keys():
                del self._coefficients[deg]
        else:
            self._coefficients[deg] = c

    @property
    def coefficients(self) -&gt; Collection:
        &#34;&#34;&#34;Returns the coefficients as a list&#34;&#34;&#34;
        deg = 0
        res = []
        while deg &lt;= self.degree:
            res.append(self[deg])
            deg += 1
        return res

    @property
    def internal(self) -&gt; Dict[int, BaseNumber]:
        &#34;&#34;&#34;Returns the coefficients as a dict indexed by their degree
        Eschews null terms&#34;&#34;&#34;
        return dict({deg: c for deg, c in self._coefficients.items()})

    @property
    def copy(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns a copy of itself&#34;&#34;&#34;
        res = self.null
        for deg, c in self.internal.items():
            res.set_term(deg, c)
        return res

    @property
    def null(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns the null polynomial&#34;&#34;&#34;
        return Polynomial([], base_field=self.base_field, indeterminate=self.indeterminate)

    def monic(self, degree: int = 1) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns a monic polynomial with a single term of a given degree&#34;&#34;&#34;
        res = self.null
        res.set_term(degree, self.base_field.one)
        return res

    @property
    def unit(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Return 1 as a polynomial of degree 0&#34;&#34;&#34;
        return self.monic(0)

    @property
    def is_constant(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is of degree zero and is not null&#34;&#34;&#34;
        return self.degree == 0 and not self.is_null

    @property
    def is_monic(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the leading coefficient is one&#34;&#34;&#34;
        return self._coefficients[self.degree] == self.base_field.one

    @property
    def is_null(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if all coefficients are zero&#34;&#34;&#34;
        return len(self._coefficients.keys()) == 0

    @property
    def is_unit(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is constant of constant term 1&#34;&#34;&#34;
        return self == self.unit

    @property
    def is_abs_unit(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is contant of constant term 1 or -1&#34;&#34;&#34;
        return self in (self.monic(0), -self.monic(0))

    @property
    def is_irreducible(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is irreducible&#34;&#34;&#34;
        return self.check_irreducibility()

    @property
    def degree(self) -&gt; int:
        &#34;&#34;&#34;Returns the degree of the polynomial&#34;&#34;&#34;
        if self.is_null:
            return 0  # rigorously, it should be -infinity
        else:
            return max(self._coefficients.keys())

    @property
    def constant(self) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the value of the coefficient of the term of degree 0&#34;&#34;&#34;
        if not self.is_null:
            return self[0]
        else:
            return self.base_field.zero

    @property
    def leading(self) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the value of the coefficient of the term of highest degree&#34;&#34;&#34;
        if not self.is_null:
            return self._coefficients[self.degree]
        else:
            return self.base_field.zero

    @property
    def trailing(self) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the value of the coefficient of the term of lowest degree&#34;&#34;&#34;
        if self.is_null:
            return self.base_field.zero
        else:
            return self._coefficients[self.valuation]

    @property
    def valuation(self) -&gt; int:
        &#34;&#34;&#34;Returns the degree of the term of lowest degree&#34;&#34;&#34;
        if self.is_null:
            raise ValueError(&#39;The valuation of the null polynomial is undefined&#39;)

        return min(self._coefficients.keys())

    def make_monic(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;
        Attempts to divide the polynomial by its leading coefficient (for a field) or by the gcd of its
        coefficients (for a ring)
        :return: a monic polynomial or raises an error if the polynomial cannot be made monic
        &#34;&#34;&#34;
        if not self.is_monic:
            if self.base_field.characteristic != 0:
                return self / self.leading
            else:
                g = rgcd(self.coefficients)
                if self.leading // g == self.base_field.one:
                    return self // self.leading
                else:
                    raise ValueError(f&#39;Polynomial {self} over {self.base_field} cannot be made monic&#39;)

        else:
            return self.copy

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of non zero terms&#34;&#34;&#34;
        return len([c for c in self._coefficients.values() if c != 0])

    def __getitem__(self, degree: int) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the coefficient of the term of a given degree&#34;&#34;&#34;
        if degree in self._coefficients.keys():
            return self._coefficients[degree]
        else:
            return self.base_field.zero

    def __eq__(self, other: Operand) -&gt; bool:
        &#34;&#34;&#34;Term-wise comparison of two polynomials&#34;&#34;&#34;
        if isinstance(other, Polynomial):
            if self.degree == other.degree:

                if self.is_null or other.is_null:
                    return self.is_null and other.is_null

                a = self.coefficients
                b = other.coefficients

                assert len(a) == len(b)
                return a == b
            else:
                return False
        else:
            other = self(other)
            return self == other

    def add(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Addition in a ring of polynomials&#34;&#34;&#34;
        a = self._coefficients
        s = poly.copy
        for deg_a, c_a in a.items():
            if deg_a in s.internal.keys():
                s.set_term(deg_a, s[deg_a] + c_a)
            else:
                s.set_term(deg_a, c_a)

        return s

    def add_constant(self, k: BaseNumber) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;External addition of a polynomial&#34;&#34;&#34;
        a = self._coefficients
        s = self.null

        if not self.is_null:
            for deg, c in a.items():
                if deg == 0:
                    s.set_term(deg, c + k)
                else:
                    s.set_term(deg, c)
        else:
            s.set_term(0, k)

        return s

    def __add__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, Polynomial):
            return self.add(other)
        elif isinstance(other, list):
            return self.add(Polynomial(other, base_field=self.base_field))
        else:
            return self.add_constant(other)

    def __radd__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.__add__(other)

    def __neg__(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns the inverse of a polynomial with respect to addition&#34;&#34;&#34;
        a = self._coefficients
        s = self.null
        for deg, c in a.items():
            s.set_term(deg, -c)
        return s

    def mul(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Multiplication in a ring of polynomials&#34;&#34;&#34;
        if poly.is_null or self.is_null:
            return self.null

        res = self.null
        for deg_p, c_p in poly.internal.items():
            a = self._coefficients
            for deg_a, c_a in a.items():
                deg = deg_a + deg_p
                if deg in res._coefficients.keys():
                    res.set_term(deg, res[deg] + c_p * c_a)
                else:
                    res.set_term(deg, c_p * c_a)

        return res

    def mul_constant(self, k: BaseNumber) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;External multiplication (vector space external product)&#34;&#34;&#34;
        s = self.null
        if k != self.base_field.zero:
            for deg, c in self._coefficients.items():
                s.set_term(deg, k * c)
        return s

    def __mul__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, Polynomial):
            return self.mul(other)
        elif isinstance(other, list):
            return self.mul(Polynomial(other, base_field=self.base_field))
        else:
            return self.mul_constant(other)

    def __rmul__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.__mul__(other)

    def sub(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Subtraction is indeed just an addition of an inverse&#34;&#34;&#34;
        assert isinstance(poly, Polynomial)
        return self.add(-poly)

    def __sub__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, (int, float,)):
            return self.add_constant(-other)
        elif isinstance(other, list):
            return self.sub(Polynomial(other, base_field=self.base_field))
        else:
            return self.sub(other)

    def __pow__(self, n: int, modulo: &#39;Polynomial&#39; = None) -&gt; &#39;Polynomial&#39;:
        return self.pow(n)

    def pow(self, n: int) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Exponentiation of a polynomial&#34;&#34;&#34;
        assert n &gt;= 0
        if self.is_unit:
            return self.unit

        if n == 0:
            return self.unit

        if n == 1:
            return self.copy

        if self.is_null:
            return self.null

        return power(self.copy, n)

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Allows a polynomial to become a dictionary key&#34;&#34;&#34;
        return hash(tuple(self._coefficients.items()))

    def long_division(self, divisor: &#39;Polynomial&#39;) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
        &#34;&#34;&#34;Defines the long division according to decreasing degrees
        Be careful if the coefficients are from a ring&#34;&#34;&#34;

        quotient = self.null
        remainder = self.copy
        while remainder != self.null and remainder.degree &gt;= divisor.degree:
            deg = remainder.degree - divisor.degree
            if remainder.leading % divisor.leading == self.base_field.zero:
                c = remainder.leading // divisor.leading
            else:
                raise ValueError(f&#39;{remainder.leading} is not divisible by {divisor.leading}&#39;)

            if deg == 0:
                poly = self.unit.mul_constant(c)
            else:
                poly = self.monic(deg).mul_constant(c)
            quotient += poly
            remainder -= (divisor * poly)

        return quotient, remainder

    def long_division_reversed(self, divisor: &#39;Polynomial&#39;) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
        &#34;&#34;&#34;Defines the long division according to increasing degrees&#34;&#34;&#34;

        quotient = self.null
        remainder = self
        while remainder != self.null and remainder.valuation &lt;= divisor.degree:

            deg = remainder.valuation - divisor.valuation
            if remainder.trailing % divisor.trailing == 0:
                c = self.base_field(remainder.trailing // divisor.trailing)
            else:
                raise ValueError(f&#39;{remainder.trailing} is not divisible by {divisor.trailing}&#39;)
            if deg == 0:
                poly = self.unit.mul_constant(c)
            else:
                poly = self.monic(deg).mul_constant(c)
            quotient += poly
            remainder -= (divisor * poly)

        return quotient, remainder

    def __truediv__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.__floordiv__(other)

    def __floordiv__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, self.__class__):
            return self.long_division(other)[0]
        else:
            other = self.base_field.element(other)
            return self.mul_constant(self.base_field.one / other)

    def __divmod__(self, other: Operand) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
        return self.long_division(other)

    def __mod__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.long_division(other)[1]

    def __repr__(self) -&gt; str:
        s = f&#39;{repr(self.base_field)}.polynomial(&#39;
        s += f&#39;{&#34;, &#34;.join([repr(c) for c in self.coefficients])}, &#39;
        s += f&#39;indeterminate=&#34;{self.indeterminate}&#34;)&#39;
        return s

    def _format_coefficient(self, c: BaseNumber, display_plus_sign: bool = False, raw: bool = False) -&gt; str:
        sf = &#39;&#39;
        if isinstance(c, int):
            if raw:
                sf = str(c)
            else:
                if display_plus_sign:
                    if c &lt; 0:
                        sf += &#39; - &#39;
                    else:
                        sf += &#39; + &#39;
                    if abs(c) != 1:
                        sf += f&#39;{abs(c)}&#39;
                else:
                    if c &lt; 0:
                        sf += &#39;-&#39;
                    if abs(c) != 1:
                        sf += f&#39;{abs(c)}&#39;
        else:
            # rely on the override of __format__
            sc = format(c, &#39;short&#39;)
            if raw:
                sf = sc
            else:
                if display_plus_sign:
                    if sc[0] == &#39;-&#39;:
                        sf += &#39; - &#39;
                    else:
                        sf += &#39; + &#39;
                    # abs may not be defined but neg must be
                    if c != self.base_field.one and c != self.base_field.one.__neg__():
                        if sc[0] == &#39;-&#39;:
                            sf += sc[1:]
                        else:
                            sf += sc
                else:
                    if sc[0] == &#39;-&#39;:
                        sf += &#39;-&#39;
                    if c != self.base_field.one and c != self.base_field.one.__neg__():
                        if sc[0] == &#39;-&#39;:
                            sf += sc[1:]
                        else:
                            sf += sc
        return sf

    def __str__(self) -&gt; str:
        s = &#39;&#39;
        if self == self.null:
            return &#39;0&#39;

        for deg in sorted(self._coefficients.keys()):
            c = self[deg]
            if c != self.base_field.zero:
                if deg == 0:
                    s += self._format_coefficient(c, raw=True)
                else:
                    s += self._format_coefficient(c, len(s) &gt; 0)
                    s += f&#39;{self.indeterminate}&#39;
                    if deg &gt; 1:
                        s += f&#39;^{deg}&#39;
        return s

    def __call__(self, *args) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Syntactic sugar to create a polynomial from another one
        example: p = poly(1, 2, 1) -&gt; p == 1 + 2X + X^2&#34;&#34;&#34;
        return Polynomial(list(args), base_field=self.base_field, indeterminate=self.indeterminate)

    def evaluate(self, value: BaseNumber) -&gt; BaseNumber:
        &#34;&#34;&#34;Evaluate the polynomial for some value&#34;&#34;&#34;
        value = self.base_field.element(value)
        # f(k) = f(x) % (x-k)
        # f(x) = q(x)(x - k) + r (deg(r) &lt; d(x-k) = 1 =&gt; deg(r)=0
        # f(k) = r

        r = self % self.base_field.linear_polynomial(value)
        return r.trailing

    def formal_derivative(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Computes and returns the formal derivative of a polynomial&#34;&#34;&#34;
        res = self.null
        for deg, c in self.internal.items():
            if deg &gt; 0:
                res.set_term(deg - 1, self.base_field.ext_mul(deg, c))
        return res

    def gcd(self, p: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns the GCD of two polynomials&#34;&#34;&#34;
        return gcd(self, p)

    def check_irreducibility(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is irreducible
        Inspired by https://jeremykun.com/2014/03/13/programming-with-finite-fields/&#34;&#34;&#34;
        p = self.copy
        q = p.base_field.characteristic
        if q == 0:
            raise NotImplementedError(f&#39;Cannot check polynomial irreducibility in {self.base_field}&#39;)

        x = p.monic(1)
        term = x.copy

        for _ in range(p.degree // 2):
            term = term ** q % p
            if not (term - x).is_null:
                if p.gcd(term - x).degree &gt; 0:
                    return False
            else:
                return False

        return True

    def __invert__(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Return the Frobenius reciprocal with the operator ~&#34;&#34;&#34;
        return self.frobenius_reciprocal()

    def frobenius_reciprocal(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;If this polynomial can be written as R^(p*m)
        where R is a polynomial, p the field characteristic and m an integer
        then taking the p-th root &lt;=&gt; returning R^m&#34;&#34;&#34;
        assert self.base_field.characteristic &gt; 0
        if self.base_field.characteristic &gt; 0:
            &#34;&#34;&#34;if p is a power of a multiple of the field characteristic
            the function returns the base polynomial that is:
            if p == x^q where q % self.c == 0 it returns x^(q/self.c)&#34;&#34;&#34;
            assert hasattr(self.base_field, &#39;frobenius_reciprocal&#39;)
            p_th_root_func = self.base_field.frobenius_reciprocal

            if not self.formal_derivative().is_null:
                raise ValueError(f&#39;The polynomial p is not a {self.base_field.characteristic} power&#39;)
            else:
                res = self.null

                for deg in range(0, self.degree + 1):
                    if deg == 0:
                        res += p_th_root_func(self.constant)
                    else:
                        if deg % self.base_field.characteristic == 0:
                            term = self.monic(deg // self.base_field.characteristic)
                            term *= p_th_root_func(self[deg])
                            res += term
                        else:
                            assert self[deg] == 0

                return res
        else:
            raise RuntimeError(f&#39;{self.base_field} does not support taking the p-th root of a polynomial&#39;)

    @staticmethod
    def parse(expr: str, base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns a polynomial from its algebraic expression
        :param expr: an algebraic expression in the indeterminate
        :param base_field: the field (or the ring) that coefficients are to be drawn from
        :param indeterminate: a single digit string in the range [a-zA-Z]
        :return: a polynomial&#34;&#34;&#34;
        return symbolic_polynomial(expr, base_field, indeterminate=indeterminate)


def symbolic_polynomial(expression: str, base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;):
    &#34;&#34;&#34;Returns a polynomial from its algebraic expression
    :param expression: an algebraic expression in the indeterminate
    :param base_field: the field (or the ring) that coefficients are to be drawn from
    :param indeterminate: a single digit string in the range [a-zA-Z]
    :return: a polynomial&#34;&#34;&#34;
    return PolynomialParser.parse(expression, base_field, indeterminate=indeterminate)


&#34;&#34;&#34;Lexer et Parser code follows, should not be exported&#34;&#34;&#34;


class Lexer:
    INDETERMINATE = &#39;INDETERMINATE&#39;
    INTEGER = &#39;INTEGER&#39;
    OPERATOR = &#39;OPERATOR&#39;
    EXPONENT = &#39;EXPONENT&#39;
    SUBEXPR = &#39;SUBEXPR&#39;
    EOF = &#39;EOF&#39;
    IGNORE = &#39;IGNORE&#39;
    MISMATCH = &#39;MISMATCH&#39;

    class Token(namedtuple(&#39;Token&#39;, &#39;type, value, position&#39;)):
        __slots__ = ()

    def __init__(self, indeterminate: Optional[str] = &#39;X&#39;, root_symbol: Optional[str] = &#39;j&#39;):
        self.indeterminate = indeterminate
        self.root_symbol = root_symbol

        self.symbols = [
            (Lexer.INDETERMINATE, r&#39;[%s]&#39; % self.indeterminate),
            (Lexer.INTEGER, r&#39;[1-9][0-9]*&#39;),
            (Lexer.OPERATOR, r&#39;[+-]&#39;),
            (Lexer.EXPONENT, r&#39;[\^]&#39;),
            (Lexer.SUBEXPR, r&#39;\([^)]+\)&#39;),
            (Lexer.EOF, r&#39;$&#39;),
            (Lexer.IGNORE, r&#39;\s&#39;),  # must stay before the last item
            (Lexer.MISMATCH, r&#39;.&#39;)  # must stay the last item
        ]
        self.tokens_re = &#39;|&#39;.join([f&#39;(?P&lt;{tok}&gt;{re})&#39; for tok, re in self.symbols])

    def lex(self, expression: str) -&gt; Iterator[&#39;Lexer.Token&#39;]:

        for tok in finditer(self.tokens_re, expression):
            token = Lexer.Token(tok.lastgroup, tok.group(), tok.start())

            if token.type == Lexer.IGNORE:
                continue
            elif token.type == Lexer.SUBEXPR:
                # remove left and right parentheses
                lexer = Lexer(indeterminate=self.root_symbol, root_symbol=&#39;&#39;)
                yield Lexer.Token(token.type, lexer.lex(token.value[1:-1], ), token.position)

            elif token.type == Lexer.INTEGER:
                yield Lexer.Token(token.type, int(token.value), token.position)

            elif token.type == Lexer.OPERATOR:
                if token.value == &#39;+&#39;:
                    yield Lexer.Token(token.type, operator.add, token.position)
                elif token.value == &#39;-&#39;:
                    yield Lexer.Token(token.type, operator.sub, token.position)

            else:
                yield token


class ParsingContext:
    def __init__(self, base_field: BaseField, indeterminate: str):
        self.base_field = base_field
        self.indeterminate = indeterminate

        self._stack = []
        self._stack.append(self.base_field.polynomial(self.base_field.zero, indeterminate=self.indeterminate))

    def accumulate_neutral(self, *_):
        self._stack.append(self.base_field.neutral)

    def accumulate_token(self, tok: Lexer.Token, *_):
        self._stack.append(tok.value)

    def accumulate_element(self, tok: Lexer.Token, *_):
        self._stack.append(self.base_field(tok.value))

    def accumulate_literal(self, _, v: Any):
        self._stack.append(v)

    def accumulate_subexpression(self, tok: Lexer.Token, *_):
        def convert_subexpr(subexpr):
            ctx = ParsingContext(self.base_field.prime_field, indeterminate=self.base_field.root_symbol)
            return self.base_field.element_from_polynomial(PolynomialParser.start(subexpr, ctx))

        self._stack.append(convert_subexpr(tok.value))

    def reduce(self, *_):
        try:
            (result, op, coefficient, degree), self._stack = self._stack[-4:], self._stack[:-4]
            self._stack.append(op(result, result.monic(degree).mul_constant(coefficient)))
        except BaseException as e:
            raise RuntimeError(e)

    def get_result(self) -&gt; &#39;Polynomial&#39;:
        return self._stack.pop()


class PolynomialParser:

    @staticmethod
    def parse(expression: str, base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;):
        &#34;&#34;&#34;Main parsing utility&#34;&#34;&#34;
        if hasattr(base_field, &#39;root_symbol&#39;):
            lexer = Lexer(indeterminate=indeterminate, root_symbol=base_field.root_symbol)
        else:
            lexer = Lexer(indeterminate=indeterminate, root_symbol=&#39;&#39;)

        ctx = ParsingContext(base_field, indeterminate)
        return PolynomialParser.start(lexer.lex(expression), ctx)

    @staticmethod
    def start(lexer: Iterator, context: ParsingContext) -&gt; Polynomial:

        def format_syntax_error(s, t):
            return f&#39;Syntax error at {t.position}: unexpected {t} in state {s}&#39;

        state = PolynomialParser.States.starting

        for token in lexer:
            if (state, token.type) in PolynomialParser.transitions:
                transition = PolynomialParser.transitions[(state, token.type)]
                for op, args in transition.actions:
                    op(context, token, *args)
                state = transition.next_state
            else:
                raise SyntaxError(format_syntax_error(state, token))

        assert state == PolynomialParser.States.complete
        return context.get_result()

    &#34;&#34;&#34;Internals&#34;&#34;&#34;
    Transition = namedtuple(&#39;Transition&#39;, &#39;actions next_state&#39;)

    class States(Enum):
        starting = 0
        coefficient = 1
        indeterminate = 2
        exponent = 3
        sub_expression = 4
        operator = 5
        complete = 6
        init = 7

    transitions = {
        (States.starting, Lexer.INTEGER):
            Transition([
                (ParsingContext.accumulate_literal, (operator.add,)),
                (ParsingContext.accumulate_element, (),)
            ], States.coefficient),

        (States.starting, Lexer.SUBEXPR):
            Transition([
                (ParsingContext.accumulate_literal, (operator.add,)),
                (ParsingContext.accumulate_subexpression, ())
            ], States.coefficient),

        (States.starting, Lexer.OPERATOR):
            Transition([
                (ParsingContext.accumulate_token, ())
            ], States.operator),

        (States.starting, Lexer.INDETERMINATE):
            Transition([
                (ParsingContext.accumulate_literal, (operator.add,)),
                (ParsingContext.accumulate_neutral, (),)
            ], States.indeterminate),

        (States.starting, Lexer.EOF):
            Transition([], States.complete),

        (States.coefficient, Lexer.INDETERMINATE):
            Transition([], States.indeterminate),

        (States.coefficient, Lexer.OPERATOR):
            Transition([
                (ParsingContext.accumulate_literal, (0,)),
                (ParsingContext.reduce, ()),
                (ParsingContext.accumulate_token, ()),
            ], States.operator),

        (States.coefficient, Lexer.EOF):
            Transition([
                (ParsingContext.accumulate_literal, (0,)),
                (ParsingContext.reduce, ())
            ], States.complete),

        (States.operator, Lexer.INTEGER):
            Transition([
                (ParsingContext.accumulate_element, ())
            ], States.coefficient),

        (States.operator, Lexer.SUBEXPR):
            Transition([
                (ParsingContext.accumulate_subexpression, ())
            ], States.coefficient),

        (States.operator, Lexer.INDETERMINATE):
            Transition([
                (ParsingContext.accumulate_neutral, ())
            ], States.indeterminate),

        (States.indeterminate, Lexer.EXPONENT):
            Transition([], States.exponent),

        (States.indeterminate, Lexer.OPERATOR):
            Transition([
                (ParsingContext.accumulate_literal, (1,)),
                (ParsingContext.reduce, ()),
                (ParsingContext.accumulate_token, ())
            ], States.operator),

        (States.indeterminate, Lexer.EOF):
            Transition([
                (ParsingContext.accumulate_literal, (1,)),
                (ParsingContext.reduce, ())
            ], States.complete),

        (States.exponent, Lexer.INTEGER):
            Transition([
                (ParsingContext.accumulate_token, ()),
                (ParsingContext.reduce, ())
            ], States.init),

        (States.init, Lexer.OPERATOR):
            Transition([
                (ParsingContext.accumulate_token, ())
            ], States.operator),

        (States.init, Lexer.EOF):
            Transition([], States.complete)
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyimath.polynomial.symbolic_polynomial"><code class="name flex">
<span>def <span class="ident">symbolic_polynomial</span></span>(<span>expression, base_field, indeterminate='X')</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a polynomial from its algebraic expression
:param expression: an algebraic expression in the indeterminate
:param base_field: the field (or the ring) that coefficients are to be drawn from
:param indeterminate: a single digit string in the range [a-zA-Z]
:return: a polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbolic_polynomial(expression: str, base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;):
    &#34;&#34;&#34;Returns a polynomial from its algebraic expression
    :param expression: an algebraic expression in the indeterminate
    :param base_field: the field (or the ring) that coefficients are to be drawn from
    :param indeterminate: a single digit string in the range [a-zA-Z]
    :return: a polynomial&#34;&#34;&#34;
    return PolynomialParser.parse(expression, base_field, indeterminate=indeterminate)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyimath.polynomial.Polynomial"><code class="flex name class">
<span>class <span class="ident">Polynomial</span></span>
<span>(</span><span>coeffs, base_field, indeterminate='X')</span>
</code></dt>
<dd>
<section class="desc"><p>Represents a polynomial over a finite field or over the integers
More generally, definition of polynomials over a ring is possible
but not recommended
The internal representation of the coefficients uses a dict that
indexes the coefficients by their degree
The usual definition of a polynomial as a sequence of numbers
that are all zeroes from a certain index is used to initialize the polynomial
on instantiation and can be retrieved through the coefficients property
Moreover this class implements all the operations over a ring of polynomials</p>
<p>base_field must represent an integral domain that is:
a set which is an abelian group for + and a semi-group
for * and where GCD are computable.
A ring of polynomials is at least defined over an integral domain
examples: Z, Z(i)</p>
<p>:param coeffs: an iterable of elements from the base field
:param base_field: an instance generally a finite field
:param indeterminate: a single digit string used to format the polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polynomial:
    &#34;&#34;&#34;Represents a polynomial over a finite field or over the integers
    More generally, definition of polynomials over a ring is possible
    but not recommended
    The internal representation of the coefficients uses a dict that
    indexes the coefficients by their degree
    The usual definition of a polynomial as a sequence of numbers
    that are all zeroes from a certain index is used to initialize the polynomial
    on instantiation and can be retrieved through the coefficients property
    Moreover this class implements all the operations over a ring of polynomials

    base_field must represent an integral domain that is:
       a set which is an abelian group for + and a semi-group
       for * and where GCD are computable.
       A ring of polynomials is at least defined over an integral domain
       examples: Z, Z(i)
    &#34;&#34;&#34;

    def __init__(self, coeffs: Sequence[BaseNumber], base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;):
        &#34;&#34;&#34;
        :param coeffs: an iterable of elements from the base field
        :param base_field: an instance generally a finite field
        :param indeterminate: a single digit string used to format the polynomial
        &#34;&#34;&#34;
        self.base_field = base_field
        assert hasattr(base_field, &#39;element&#39;) and hasattr(base_field, &#39;__call__&#39;)

        self._coefficients = self._safe_convert_coefficients(self._remove_trailing_zeros(coeffs))
        self.indeterminate = indeterminate

    def _safe_convert_coefficients(self, seq: Iterable) -&gt; Dict[int, BaseNumber]:
        bf = self.base_field
        return dict({deg: bf.element(c) for deg, c in enumerate(seq) if c != bf.zero})

    def _remove_trailing_zeros(self, seq: Sequence) -&gt; Collection:
        if len(seq) == 0:
            return []
        revseq = list(reversed(seq))
        while revseq[0] == self.base_field.zero:
            revseq = revseq[1:]
            if len(revseq) == 0:
                return []

        return list(reversed(revseq))

    def set_term(self, deg: int, c: BaseNumber):
        if c == self.base_field.zero:
            if deg in self._coefficients.keys():
                del self._coefficients[deg]
        else:
            self._coefficients[deg] = c

    @property
    def coefficients(self) -&gt; Collection:
        &#34;&#34;&#34;Returns the coefficients as a list&#34;&#34;&#34;
        deg = 0
        res = []
        while deg &lt;= self.degree:
            res.append(self[deg])
            deg += 1
        return res

    @property
    def internal(self) -&gt; Dict[int, BaseNumber]:
        &#34;&#34;&#34;Returns the coefficients as a dict indexed by their degree
        Eschews null terms&#34;&#34;&#34;
        return dict({deg: c for deg, c in self._coefficients.items()})

    @property
    def copy(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns a copy of itself&#34;&#34;&#34;
        res = self.null
        for deg, c in self.internal.items():
            res.set_term(deg, c)
        return res

    @property
    def null(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns the null polynomial&#34;&#34;&#34;
        return Polynomial([], base_field=self.base_field, indeterminate=self.indeterminate)

    def monic(self, degree: int = 1) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns a monic polynomial with a single term of a given degree&#34;&#34;&#34;
        res = self.null
        res.set_term(degree, self.base_field.one)
        return res

    @property
    def unit(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Return 1 as a polynomial of degree 0&#34;&#34;&#34;
        return self.monic(0)

    @property
    def is_constant(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is of degree zero and is not null&#34;&#34;&#34;
        return self.degree == 0 and not self.is_null

    @property
    def is_monic(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the leading coefficient is one&#34;&#34;&#34;
        return self._coefficients[self.degree] == self.base_field.one

    @property
    def is_null(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if all coefficients are zero&#34;&#34;&#34;
        return len(self._coefficients.keys()) == 0

    @property
    def is_unit(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is constant of constant term 1&#34;&#34;&#34;
        return self == self.unit

    @property
    def is_abs_unit(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is contant of constant term 1 or -1&#34;&#34;&#34;
        return self in (self.monic(0), -self.monic(0))

    @property
    def is_irreducible(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is irreducible&#34;&#34;&#34;
        return self.check_irreducibility()

    @property
    def degree(self) -&gt; int:
        &#34;&#34;&#34;Returns the degree of the polynomial&#34;&#34;&#34;
        if self.is_null:
            return 0  # rigorously, it should be -infinity
        else:
            return max(self._coefficients.keys())

    @property
    def constant(self) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the value of the coefficient of the term of degree 0&#34;&#34;&#34;
        if not self.is_null:
            return self[0]
        else:
            return self.base_field.zero

    @property
    def leading(self) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the value of the coefficient of the term of highest degree&#34;&#34;&#34;
        if not self.is_null:
            return self._coefficients[self.degree]
        else:
            return self.base_field.zero

    @property
    def trailing(self) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the value of the coefficient of the term of lowest degree&#34;&#34;&#34;
        if self.is_null:
            return self.base_field.zero
        else:
            return self._coefficients[self.valuation]

    @property
    def valuation(self) -&gt; int:
        &#34;&#34;&#34;Returns the degree of the term of lowest degree&#34;&#34;&#34;
        if self.is_null:
            raise ValueError(&#39;The valuation of the null polynomial is undefined&#39;)

        return min(self._coefficients.keys())

    def make_monic(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;
        Attempts to divide the polynomial by its leading coefficient (for a field) or by the gcd of its
        coefficients (for a ring)
        :return: a monic polynomial or raises an error if the polynomial cannot be made monic
        &#34;&#34;&#34;
        if not self.is_monic:
            if self.base_field.characteristic != 0:
                return self / self.leading
            else:
                g = rgcd(self.coefficients)
                if self.leading // g == self.base_field.one:
                    return self // self.leading
                else:
                    raise ValueError(f&#39;Polynomial {self} over {self.base_field} cannot be made monic&#39;)

        else:
            return self.copy

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of non zero terms&#34;&#34;&#34;
        return len([c for c in self._coefficients.values() if c != 0])

    def __getitem__(self, degree: int) -&gt; BaseNumber:
        &#34;&#34;&#34;Returns the coefficient of the term of a given degree&#34;&#34;&#34;
        if degree in self._coefficients.keys():
            return self._coefficients[degree]
        else:
            return self.base_field.zero

    def __eq__(self, other: Operand) -&gt; bool:
        &#34;&#34;&#34;Term-wise comparison of two polynomials&#34;&#34;&#34;
        if isinstance(other, Polynomial):
            if self.degree == other.degree:

                if self.is_null or other.is_null:
                    return self.is_null and other.is_null

                a = self.coefficients
                b = other.coefficients

                assert len(a) == len(b)
                return a == b
            else:
                return False
        else:
            other = self(other)
            return self == other

    def add(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Addition in a ring of polynomials&#34;&#34;&#34;
        a = self._coefficients
        s = poly.copy
        for deg_a, c_a in a.items():
            if deg_a in s.internal.keys():
                s.set_term(deg_a, s[deg_a] + c_a)
            else:
                s.set_term(deg_a, c_a)

        return s

    def add_constant(self, k: BaseNumber) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;External addition of a polynomial&#34;&#34;&#34;
        a = self._coefficients
        s = self.null

        if not self.is_null:
            for deg, c in a.items():
                if deg == 0:
                    s.set_term(deg, c + k)
                else:
                    s.set_term(deg, c)
        else:
            s.set_term(0, k)

        return s

    def __add__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, Polynomial):
            return self.add(other)
        elif isinstance(other, list):
            return self.add(Polynomial(other, base_field=self.base_field))
        else:
            return self.add_constant(other)

    def __radd__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.__add__(other)

    def __neg__(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns the inverse of a polynomial with respect to addition&#34;&#34;&#34;
        a = self._coefficients
        s = self.null
        for deg, c in a.items():
            s.set_term(deg, -c)
        return s

    def mul(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Multiplication in a ring of polynomials&#34;&#34;&#34;
        if poly.is_null or self.is_null:
            return self.null

        res = self.null
        for deg_p, c_p in poly.internal.items():
            a = self._coefficients
            for deg_a, c_a in a.items():
                deg = deg_a + deg_p
                if deg in res._coefficients.keys():
                    res.set_term(deg, res[deg] + c_p * c_a)
                else:
                    res.set_term(deg, c_p * c_a)

        return res

    def mul_constant(self, k: BaseNumber) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;External multiplication (vector space external product)&#34;&#34;&#34;
        s = self.null
        if k != self.base_field.zero:
            for deg, c in self._coefficients.items():
                s.set_term(deg, k * c)
        return s

    def __mul__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, Polynomial):
            return self.mul(other)
        elif isinstance(other, list):
            return self.mul(Polynomial(other, base_field=self.base_field))
        else:
            return self.mul_constant(other)

    def __rmul__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.__mul__(other)

    def sub(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Subtraction is indeed just an addition of an inverse&#34;&#34;&#34;
        assert isinstance(poly, Polynomial)
        return self.add(-poly)

    def __sub__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, (int, float,)):
            return self.add_constant(-other)
        elif isinstance(other, list):
            return self.sub(Polynomial(other, base_field=self.base_field))
        else:
            return self.sub(other)

    def __pow__(self, n: int, modulo: &#39;Polynomial&#39; = None) -&gt; &#39;Polynomial&#39;:
        return self.pow(n)

    def pow(self, n: int) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Exponentiation of a polynomial&#34;&#34;&#34;
        assert n &gt;= 0
        if self.is_unit:
            return self.unit

        if n == 0:
            return self.unit

        if n == 1:
            return self.copy

        if self.is_null:
            return self.null

        return power(self.copy, n)

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Allows a polynomial to become a dictionary key&#34;&#34;&#34;
        return hash(tuple(self._coefficients.items()))

    def long_division(self, divisor: &#39;Polynomial&#39;) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
        &#34;&#34;&#34;Defines the long division according to decreasing degrees
        Be careful if the coefficients are from a ring&#34;&#34;&#34;

        quotient = self.null
        remainder = self.copy
        while remainder != self.null and remainder.degree &gt;= divisor.degree:
            deg = remainder.degree - divisor.degree
            if remainder.leading % divisor.leading == self.base_field.zero:
                c = remainder.leading // divisor.leading
            else:
                raise ValueError(f&#39;{remainder.leading} is not divisible by {divisor.leading}&#39;)

            if deg == 0:
                poly = self.unit.mul_constant(c)
            else:
                poly = self.monic(deg).mul_constant(c)
            quotient += poly
            remainder -= (divisor * poly)

        return quotient, remainder

    def long_division_reversed(self, divisor: &#39;Polynomial&#39;) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
        &#34;&#34;&#34;Defines the long division according to increasing degrees&#34;&#34;&#34;

        quotient = self.null
        remainder = self
        while remainder != self.null and remainder.valuation &lt;= divisor.degree:

            deg = remainder.valuation - divisor.valuation
            if remainder.trailing % divisor.trailing == 0:
                c = self.base_field(remainder.trailing // divisor.trailing)
            else:
                raise ValueError(f&#39;{remainder.trailing} is not divisible by {divisor.trailing}&#39;)
            if deg == 0:
                poly = self.unit.mul_constant(c)
            else:
                poly = self.monic(deg).mul_constant(c)
            quotient += poly
            remainder -= (divisor * poly)

        return quotient, remainder

    def __truediv__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.__floordiv__(other)

    def __floordiv__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        if isinstance(other, self.__class__):
            return self.long_division(other)[0]
        else:
            other = self.base_field.element(other)
            return self.mul_constant(self.base_field.one / other)

    def __divmod__(self, other: Operand) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
        return self.long_division(other)

    def __mod__(self, other: Operand) -&gt; &#39;Polynomial&#39;:
        return self.long_division(other)[1]

    def __repr__(self) -&gt; str:
        s = f&#39;{repr(self.base_field)}.polynomial(&#39;
        s += f&#39;{&#34;, &#34;.join([repr(c) for c in self.coefficients])}, &#39;
        s += f&#39;indeterminate=&#34;{self.indeterminate}&#34;)&#39;
        return s

    def _format_coefficient(self, c: BaseNumber, display_plus_sign: bool = False, raw: bool = False) -&gt; str:
        sf = &#39;&#39;
        if isinstance(c, int):
            if raw:
                sf = str(c)
            else:
                if display_plus_sign:
                    if c &lt; 0:
                        sf += &#39; - &#39;
                    else:
                        sf += &#39; + &#39;
                    if abs(c) != 1:
                        sf += f&#39;{abs(c)}&#39;
                else:
                    if c &lt; 0:
                        sf += &#39;-&#39;
                    if abs(c) != 1:
                        sf += f&#39;{abs(c)}&#39;
        else:
            # rely on the override of __format__
            sc = format(c, &#39;short&#39;)
            if raw:
                sf = sc
            else:
                if display_plus_sign:
                    if sc[0] == &#39;-&#39;:
                        sf += &#39; - &#39;
                    else:
                        sf += &#39; + &#39;
                    # abs may not be defined but neg must be
                    if c != self.base_field.one and c != self.base_field.one.__neg__():
                        if sc[0] == &#39;-&#39;:
                            sf += sc[1:]
                        else:
                            sf += sc
                else:
                    if sc[0] == &#39;-&#39;:
                        sf += &#39;-&#39;
                    if c != self.base_field.one and c != self.base_field.one.__neg__():
                        if sc[0] == &#39;-&#39;:
                            sf += sc[1:]
                        else:
                            sf += sc
        return sf

    def __str__(self) -&gt; str:
        s = &#39;&#39;
        if self == self.null:
            return &#39;0&#39;

        for deg in sorted(self._coefficients.keys()):
            c = self[deg]
            if c != self.base_field.zero:
                if deg == 0:
                    s += self._format_coefficient(c, raw=True)
                else:
                    s += self._format_coefficient(c, len(s) &gt; 0)
                    s += f&#39;{self.indeterminate}&#39;
                    if deg &gt; 1:
                        s += f&#39;^{deg}&#39;
        return s

    def __call__(self, *args) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Syntactic sugar to create a polynomial from another one
        example: p = poly(1, 2, 1) -&gt; p == 1 + 2X + X^2&#34;&#34;&#34;
        return Polynomial(list(args), base_field=self.base_field, indeterminate=self.indeterminate)

    def evaluate(self, value: BaseNumber) -&gt; BaseNumber:
        &#34;&#34;&#34;Evaluate the polynomial for some value&#34;&#34;&#34;
        value = self.base_field.element(value)
        # f(k) = f(x) % (x-k)
        # f(x) = q(x)(x - k) + r (deg(r) &lt; d(x-k) = 1 =&gt; deg(r)=0
        # f(k) = r

        r = self % self.base_field.linear_polynomial(value)
        return r.trailing

    def formal_derivative(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Computes and returns the formal derivative of a polynomial&#34;&#34;&#34;
        res = self.null
        for deg, c in self.internal.items():
            if deg &gt; 0:
                res.set_term(deg - 1, self.base_field.ext_mul(deg, c))
        return res

    def gcd(self, p: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns the GCD of two polynomials&#34;&#34;&#34;
        return gcd(self, p)

    def check_irreducibility(self) -&gt; bool:
        &#34;&#34;&#34;Returns True if the polynomial is irreducible
        Inspired by https://jeremykun.com/2014/03/13/programming-with-finite-fields/&#34;&#34;&#34;
        p = self.copy
        q = p.base_field.characteristic
        if q == 0:
            raise NotImplementedError(f&#39;Cannot check polynomial irreducibility in {self.base_field}&#39;)

        x = p.monic(1)
        term = x.copy

        for _ in range(p.degree // 2):
            term = term ** q % p
            if not (term - x).is_null:
                if p.gcd(term - x).degree &gt; 0:
                    return False
            else:
                return False

        return True

    def __invert__(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Return the Frobenius reciprocal with the operator ~&#34;&#34;&#34;
        return self.frobenius_reciprocal()

    def frobenius_reciprocal(self) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;If this polynomial can be written as R^(p*m)
        where R is a polynomial, p the field characteristic and m an integer
        then taking the p-th root &lt;=&gt; returning R^m&#34;&#34;&#34;
        assert self.base_field.characteristic &gt; 0
        if self.base_field.characteristic &gt; 0:
            &#34;&#34;&#34;if p is a power of a multiple of the field characteristic
            the function returns the base polynomial that is:
            if p == x^q where q % self.c == 0 it returns x^(q/self.c)&#34;&#34;&#34;
            assert hasattr(self.base_field, &#39;frobenius_reciprocal&#39;)
            p_th_root_func = self.base_field.frobenius_reciprocal

            if not self.formal_derivative().is_null:
                raise ValueError(f&#39;The polynomial p is not a {self.base_field.characteristic} power&#39;)
            else:
                res = self.null

                for deg in range(0, self.degree + 1):
                    if deg == 0:
                        res += p_th_root_func(self.constant)
                    else:
                        if deg % self.base_field.characteristic == 0:
                            term = self.monic(deg // self.base_field.characteristic)
                            term *= p_th_root_func(self[deg])
                            res += term
                        else:
                            assert self[deg] == 0

                return res
        else:
            raise RuntimeError(f&#39;{self.base_field} does not support taking the p-th root of a polynomial&#39;)

    @staticmethod
    def parse(expr: str, base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;) -&gt; &#39;Polynomial&#39;:
        &#34;&#34;&#34;Returns a polynomial from its algebraic expression
        :param expr: an algebraic expression in the indeterminate
        :param base_field: the field (or the ring) that coefficients are to be drawn from
        :param indeterminate: a single digit string in the range [a-zA-Z]
        :return: a polynomial&#34;&#34;&#34;
        return symbolic_polynomial(expr, base_field, indeterminate=indeterminate)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyimath.polynomial.Polynomial.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>expr, base_field, indeterminate='X')</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a polynomial from its algebraic expression
:param expr: an algebraic expression in the indeterminate
:param base_field: the field (or the ring) that coefficients are to be drawn from
:param indeterminate: a single digit string in the range [a-zA-Z]
:return: a polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def parse(expr: str, base_field: BaseField, indeterminate: Optional[str] = &#39;X&#39;) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Returns a polynomial from its algebraic expression
    :param expr: an algebraic expression in the indeterminate
    :param base_field: the field (or the ring) that coefficients are to be drawn from
    :param indeterminate: a single digit string in the range [a-zA-Z]
    :return: a polynomial&#34;&#34;&#34;
    return symbolic_polynomial(expr, base_field, indeterminate=indeterminate)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyimath.polynomial.Polynomial.coefficients"><code class="name">var <span class="ident">coefficients</span></code></dt>
<dd>
<section class="desc"><p>Returns the coefficients as a list</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coefficients(self) -&gt; Collection:
    &#34;&#34;&#34;Returns the coefficients as a list&#34;&#34;&#34;
    deg = 0
    res = []
    while deg &lt;= self.degree:
        res.append(self[deg])
        deg += 1
    return res</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.constant"><code class="name">var <span class="ident">constant</span></code></dt>
<dd>
<section class="desc"><p>Returns the value of the coefficient of the term of degree 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def constant(self) -&gt; BaseNumber:
    &#34;&#34;&#34;Returns the value of the coefficient of the term of degree 0&#34;&#34;&#34;
    if not self.is_null:
        return self[0]
    else:
        return self.base_field.zero</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.copy"><code class="name">var <span class="ident">copy</span></code></dt>
<dd>
<section class="desc"><p>Returns a copy of itself</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def copy(self) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Returns a copy of itself&#34;&#34;&#34;
    res = self.null
    for deg, c in self.internal.items():
        res.set_term(deg, c)
    return res</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.degree"><code class="name">var <span class="ident">degree</span></code></dt>
<dd>
<section class="desc"><p>Returns the degree of the polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def degree(self) -&gt; int:
    &#34;&#34;&#34;Returns the degree of the polynomial&#34;&#34;&#34;
    if self.is_null:
        return 0  # rigorously, it should be -infinity
    else:
        return max(self._coefficients.keys())</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.internal"><code class="name">var <span class="ident">internal</span></code></dt>
<dd>
<section class="desc"><p>Returns the coefficients as a dict indexed by their degree
Eschews null terms</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal(self) -&gt; Dict[int, BaseNumber]:
    &#34;&#34;&#34;Returns the coefficients as a dict indexed by their degree
    Eschews null terms&#34;&#34;&#34;
    return dict({deg: c for deg, c in self._coefficients.items()})</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.is_abs_unit"><code class="name">var <span class="ident">is_abs_unit</span></code></dt>
<dd>
<section class="desc"><p>Returns True if the polynomial is contant of constant term 1 or -1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_abs_unit(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the polynomial is contant of constant term 1 or -1&#34;&#34;&#34;
    return self in (self.monic(0), -self.monic(0))</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.is_constant"><code class="name">var <span class="ident">is_constant</span></code></dt>
<dd>
<section class="desc"><p>Returns True if the polynomial is of degree zero and is not null</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_constant(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the polynomial is of degree zero and is not null&#34;&#34;&#34;
    return self.degree == 0 and not self.is_null</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.is_irreducible"><code class="name">var <span class="ident">is_irreducible</span></code></dt>
<dd>
<section class="desc"><p>Returns True if the polynomial is irreducible</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_irreducible(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the polynomial is irreducible&#34;&#34;&#34;
    return self.check_irreducibility()</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.is_monic"><code class="name">var <span class="ident">is_monic</span></code></dt>
<dd>
<section class="desc"><p>Returns True if the leading coefficient is one</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_monic(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the leading coefficient is one&#34;&#34;&#34;
    return self._coefficients[self.degree] == self.base_field.one</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.is_null"><code class="name">var <span class="ident">is_null</span></code></dt>
<dd>
<section class="desc"><p>Returns True if all coefficients are zero</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_null(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if all coefficients are zero&#34;&#34;&#34;
    return len(self._coefficients.keys()) == 0</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.is_unit"><code class="name">var <span class="ident">is_unit</span></code></dt>
<dd>
<section class="desc"><p>Returns True if the polynomial is constant of constant term 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_unit(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the polynomial is constant of constant term 1&#34;&#34;&#34;
    return self == self.unit</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.leading"><code class="name">var <span class="ident">leading</span></code></dt>
<dd>
<section class="desc"><p>Returns the value of the coefficient of the term of highest degree</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def leading(self) -&gt; BaseNumber:
    &#34;&#34;&#34;Returns the value of the coefficient of the term of highest degree&#34;&#34;&#34;
    if not self.is_null:
        return self._coefficients[self.degree]
    else:
        return self.base_field.zero</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.null"><code class="name">var <span class="ident">null</span></code></dt>
<dd>
<section class="desc"><p>Returns the null polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def null(self) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Returns the null polynomial&#34;&#34;&#34;
    return Polynomial([], base_field=self.base_field, indeterminate=self.indeterminate)</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.trailing"><code class="name">var <span class="ident">trailing</span></code></dt>
<dd>
<section class="desc"><p>Returns the value of the coefficient of the term of lowest degree</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trailing(self) -&gt; BaseNumber:
    &#34;&#34;&#34;Returns the value of the coefficient of the term of lowest degree&#34;&#34;&#34;
    if self.is_null:
        return self.base_field.zero
    else:
        return self._coefficients[self.valuation]</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.unit"><code class="name">var <span class="ident">unit</span></code></dt>
<dd>
<section class="desc"><p>Return 1 as a polynomial of degree 0</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit(self) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Return 1 as a polynomial of degree 0&#34;&#34;&#34;
    return self.monic(0)</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.valuation"><code class="name">var <span class="ident">valuation</span></code></dt>
<dd>
<section class="desc"><p>Returns the degree of the term of lowest degree</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def valuation(self) -&gt; int:
    &#34;&#34;&#34;Returns the degree of the term of lowest degree&#34;&#34;&#34;
    if self.is_null:
        raise ValueError(&#39;The valuation of the null polynomial is undefined&#39;)

    return min(self._coefficients.keys())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyimath.polynomial.Polynomial.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, poly)</span>
</code></dt>
<dd>
<section class="desc"><p>Addition in a ring of polynomials</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Addition in a ring of polynomials&#34;&#34;&#34;
    a = self._coefficients
    s = poly.copy
    for deg_a, c_a in a.items():
        if deg_a in s.internal.keys():
            s.set_term(deg_a, s[deg_a] + c_a)
        else:
            s.set_term(deg_a, c_a)

    return s</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.add_constant"><code class="name flex">
<span>def <span class="ident">add_constant</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<section class="desc"><p>External addition of a polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_constant(self, k: BaseNumber) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;External addition of a polynomial&#34;&#34;&#34;
    a = self._coefficients
    s = self.null

    if not self.is_null:
        for deg, c in a.items():
            if deg == 0:
                s.set_term(deg, c + k)
            else:
                s.set_term(deg, c)
    else:
        s.set_term(0, k)

    return s</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.check_irreducibility"><code class="name flex">
<span>def <span class="ident">check_irreducibility</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns True if the polynomial is irreducible
Inspired by <a href="https://jeremykun.com/2014/03/13/programming-with-finite-fields/">https://jeremykun.com/2014/03/13/programming-with-finite-fields/</a></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_irreducibility(self) -&gt; bool:
    &#34;&#34;&#34;Returns True if the polynomial is irreducible
    Inspired by https://jeremykun.com/2014/03/13/programming-with-finite-fields/&#34;&#34;&#34;
    p = self.copy
    q = p.base_field.characteristic
    if q == 0:
        raise NotImplementedError(f&#39;Cannot check polynomial irreducibility in {self.base_field}&#39;)

    x = p.monic(1)
    term = x.copy

    for _ in range(p.degree // 2):
        term = term ** q % p
        if not (term - x).is_null:
            if p.gcd(term - x).degree &gt; 0:
                return False
        else:
            return False

    return True</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.evaluate"><code class="name flex">
<span>def <span class="ident">evaluate</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Evaluate the polynomial for some value</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate(self, value: BaseNumber) -&gt; BaseNumber:
    &#34;&#34;&#34;Evaluate the polynomial for some value&#34;&#34;&#34;
    value = self.base_field.element(value)
    # f(k) = f(x) % (x-k)
    # f(x) = q(x)(x - k) + r (deg(r) &lt; d(x-k) = 1 =&gt; deg(r)=0
    # f(k) = r

    r = self % self.base_field.linear_polynomial(value)
    return r.trailing</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.formal_derivative"><code class="name flex">
<span>def <span class="ident">formal_derivative</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes and returns the formal derivative of a polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formal_derivative(self) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Computes and returns the formal derivative of a polynomial&#34;&#34;&#34;
    res = self.null
    for deg, c in self.internal.items():
        if deg &gt; 0:
            res.set_term(deg - 1, self.base_field.ext_mul(deg, c))
    return res</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.frobenius_reciprocal"><code class="name flex">
<span>def <span class="ident">frobenius_reciprocal</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>If this polynomial can be written as R^(p*m)
where R is a polynomial, p the field characteristic and m an integer
then taking the p-th root &lt;=&gt; returning R^m</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frobenius_reciprocal(self) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;If this polynomial can be written as R^(p*m)
    where R is a polynomial, p the field characteristic and m an integer
    then taking the p-th root &lt;=&gt; returning R^m&#34;&#34;&#34;
    assert self.base_field.characteristic &gt; 0
    if self.base_field.characteristic &gt; 0:
        &#34;&#34;&#34;if p is a power of a multiple of the field characteristic
        the function returns the base polynomial that is:
        if p == x^q where q % self.c == 0 it returns x^(q/self.c)&#34;&#34;&#34;
        assert hasattr(self.base_field, &#39;frobenius_reciprocal&#39;)
        p_th_root_func = self.base_field.frobenius_reciprocal

        if not self.formal_derivative().is_null:
            raise ValueError(f&#39;The polynomial p is not a {self.base_field.characteristic} power&#39;)
        else:
            res = self.null

            for deg in range(0, self.degree + 1):
                if deg == 0:
                    res += p_th_root_func(self.constant)
                else:
                    if deg % self.base_field.characteristic == 0:
                        term = self.monic(deg // self.base_field.characteristic)
                        term *= p_th_root_func(self[deg])
                        res += term
                    else:
                        assert self[deg] == 0

            return res
    else:
        raise RuntimeError(f&#39;{self.base_field} does not support taking the p-th root of a polynomial&#39;)</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.gcd"><code class="name flex">
<span>def <span class="ident">gcd</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the GCD of two polynomials</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gcd(self, p: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Returns the GCD of two polynomials&#34;&#34;&#34;
    return gcd(self, p)</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.long_division"><code class="name flex">
<span>def <span class="ident">long_division</span></span>(<span>self, divisor)</span>
</code></dt>
<dd>
<section class="desc"><p>Defines the long division according to decreasing degrees
Be careful if the coefficients are from a ring</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def long_division(self, divisor: &#39;Polynomial&#39;) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
    &#34;&#34;&#34;Defines the long division according to decreasing degrees
    Be careful if the coefficients are from a ring&#34;&#34;&#34;

    quotient = self.null
    remainder = self.copy
    while remainder != self.null and remainder.degree &gt;= divisor.degree:
        deg = remainder.degree - divisor.degree
        if remainder.leading % divisor.leading == self.base_field.zero:
            c = remainder.leading // divisor.leading
        else:
            raise ValueError(f&#39;{remainder.leading} is not divisible by {divisor.leading}&#39;)

        if deg == 0:
            poly = self.unit.mul_constant(c)
        else:
            poly = self.monic(deg).mul_constant(c)
        quotient += poly
        remainder -= (divisor * poly)

    return quotient, remainder</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.long_division_reversed"><code class="name flex">
<span>def <span class="ident">long_division_reversed</span></span>(<span>self, divisor)</span>
</code></dt>
<dd>
<section class="desc"><p>Defines the long division according to increasing degrees</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def long_division_reversed(self, divisor: &#39;Polynomial&#39;) -&gt; Tuple[&#39;Polynomial&#39;, &#39;Polynomial&#39;]:
    &#34;&#34;&#34;Defines the long division according to increasing degrees&#34;&#34;&#34;

    quotient = self.null
    remainder = self
    while remainder != self.null and remainder.valuation &lt;= divisor.degree:

        deg = remainder.valuation - divisor.valuation
        if remainder.trailing % divisor.trailing == 0:
            c = self.base_field(remainder.trailing // divisor.trailing)
        else:
            raise ValueError(f&#39;{remainder.trailing} is not divisible by {divisor.trailing}&#39;)
        if deg == 0:
            poly = self.unit.mul_constant(c)
        else:
            poly = self.monic(deg).mul_constant(c)
        quotient += poly
        remainder -= (divisor * poly)

    return quotient, remainder</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.make_monic"><code class="name flex">
<span>def <span class="ident">make_monic</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Attempts to divide the polynomial by its leading coefficient (for a field) or by the gcd of its
coefficients (for a ring)
:return: a monic polynomial or raises an error if the polynomial cannot be made monic</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_monic(self) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;
    Attempts to divide the polynomial by its leading coefficient (for a field) or by the gcd of its
    coefficients (for a ring)
    :return: a monic polynomial or raises an error if the polynomial cannot be made monic
    &#34;&#34;&#34;
    if not self.is_monic:
        if self.base_field.characteristic != 0:
            return self / self.leading
        else:
            g = rgcd(self.coefficients)
            if self.leading // g == self.base_field.one:
                return self // self.leading
            else:
                raise ValueError(f&#39;Polynomial {self} over {self.base_field} cannot be made monic&#39;)

    else:
        return self.copy</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.monic"><code class="name flex">
<span>def <span class="ident">monic</span></span>(<span>self, degree=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a monic polynomial with a single term of a given degree</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def monic(self, degree: int = 1) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Returns a monic polynomial with a single term of a given degree&#34;&#34;&#34;
    res = self.null
    res.set_term(degree, self.base_field.one)
    return res</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.mul"><code class="name flex">
<span>def <span class="ident">mul</span></span>(<span>self, poly)</span>
</code></dt>
<dd>
<section class="desc"><p>Multiplication in a ring of polynomials</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mul(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Multiplication in a ring of polynomials&#34;&#34;&#34;
    if poly.is_null or self.is_null:
        return self.null

    res = self.null
    for deg_p, c_p in poly.internal.items():
        a = self._coefficients
        for deg_a, c_a in a.items():
            deg = deg_a + deg_p
            if deg in res._coefficients.keys():
                res.set_term(deg, res[deg] + c_p * c_a)
            else:
                res.set_term(deg, c_p * c_a)

    return res</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.mul_constant"><code class="name flex">
<span>def <span class="ident">mul_constant</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<section class="desc"><p>External multiplication (vector space external product)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mul_constant(self, k: BaseNumber) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;External multiplication (vector space external product)&#34;&#34;&#34;
    s = self.null
    if k != self.base_field.zero:
        for deg, c in self._coefficients.items():
            s.set_term(deg, k * c)
    return s</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.pow"><code class="name flex">
<span>def <span class="ident">pow</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Exponentiation of a polynomial</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pow(self, n: int) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Exponentiation of a polynomial&#34;&#34;&#34;
    assert n &gt;= 0
    if self.is_unit:
        return self.unit

    if n == 0:
        return self.unit

    if n == 1:
        return self.copy

    if self.is_null:
        return self.null

    return power(self.copy, n)</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.set_term"><code class="name flex">
<span>def <span class="ident">set_term</span></span>(<span>self, deg, c)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_term(self, deg: int, c: BaseNumber):
    if c == self.base_field.zero:
        if deg in self._coefficients.keys():
            del self._coefficients[deg]
    else:
        self._coefficients[deg] = c</code></pre>
</details>
</dd>
<dt id="pyimath.polynomial.Polynomial.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>self, poly)</span>
</code></dt>
<dd>
<section class="desc"><p>Subtraction is indeed just an addition of an inverse</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub(self, poly: &#39;Polynomial&#39;) -&gt; &#39;Polynomial&#39;:
    &#34;&#34;&#34;Subtraction is indeed just an addition of an inverse&#34;&#34;&#34;
    assert isinstance(poly, Polynomial)
    return self.add(-poly)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyimath" href="index.html">pyimath</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyimath.polynomial.symbolic_polynomial" href="#pyimath.polynomial.symbolic_polynomial">symbolic_polynomial</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyimath.polynomial.Polynomial" href="#pyimath.polynomial.Polynomial">Polynomial</a></code></h4>
<ul class="">
<li><code><a title="pyimath.polynomial.Polynomial.add" href="#pyimath.polynomial.Polynomial.add">add</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.add_constant" href="#pyimath.polynomial.Polynomial.add_constant">add_constant</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.check_irreducibility" href="#pyimath.polynomial.Polynomial.check_irreducibility">check_irreducibility</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.coefficients" href="#pyimath.polynomial.Polynomial.coefficients">coefficients</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.constant" href="#pyimath.polynomial.Polynomial.constant">constant</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.copy" href="#pyimath.polynomial.Polynomial.copy">copy</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.degree" href="#pyimath.polynomial.Polynomial.degree">degree</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.evaluate" href="#pyimath.polynomial.Polynomial.evaluate">evaluate</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.formal_derivative" href="#pyimath.polynomial.Polynomial.formal_derivative">formal_derivative</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.frobenius_reciprocal" href="#pyimath.polynomial.Polynomial.frobenius_reciprocal">frobenius_reciprocal</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.gcd" href="#pyimath.polynomial.Polynomial.gcd">gcd</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.internal" href="#pyimath.polynomial.Polynomial.internal">internal</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.is_abs_unit" href="#pyimath.polynomial.Polynomial.is_abs_unit">is_abs_unit</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.is_constant" href="#pyimath.polynomial.Polynomial.is_constant">is_constant</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.is_irreducible" href="#pyimath.polynomial.Polynomial.is_irreducible">is_irreducible</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.is_monic" href="#pyimath.polynomial.Polynomial.is_monic">is_monic</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.is_null" href="#pyimath.polynomial.Polynomial.is_null">is_null</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.is_unit" href="#pyimath.polynomial.Polynomial.is_unit">is_unit</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.leading" href="#pyimath.polynomial.Polynomial.leading">leading</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.long_division" href="#pyimath.polynomial.Polynomial.long_division">long_division</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.long_division_reversed" href="#pyimath.polynomial.Polynomial.long_division_reversed">long_division_reversed</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.make_monic" href="#pyimath.polynomial.Polynomial.make_monic">make_monic</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.monic" href="#pyimath.polynomial.Polynomial.monic">monic</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.mul" href="#pyimath.polynomial.Polynomial.mul">mul</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.mul_constant" href="#pyimath.polynomial.Polynomial.mul_constant">mul_constant</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.null" href="#pyimath.polynomial.Polynomial.null">null</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.parse" href="#pyimath.polynomial.Polynomial.parse">parse</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.pow" href="#pyimath.polynomial.Polynomial.pow">pow</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.set_term" href="#pyimath.polynomial.Polynomial.set_term">set_term</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.sub" href="#pyimath.polynomial.Polynomial.sub">sub</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.trailing" href="#pyimath.polynomial.Polynomial.trailing">trailing</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.unit" href="#pyimath.polynomial.Polynomial.unit">unit</a></code></li>
<li><code><a title="pyimath.polynomial.Polynomial.valuation" href="#pyimath.polynomial.Polynomial.valuation">valuation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>