<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.1" />
<title>pyimath.finitefield API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyimath.finitefield</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from itertools import product as cartesian_product
import operator

from typing import Optional, Sequence, MutableSequence, Iterator, Union, List, Tuple, Any, Collection


from pyimath.functions import maybe_prime
from pyimath.functions import power
from pyimath.polynomial import Polynomial, symbolic_polynomial
from pyimath.primefield import PrimeField, PFElement

__all__ = [&#39;FiniteField&#39;, &#39;finite_field&#39;, &#39;FFElement&#39;]


BaseAtom = Union[int, PFElement]
Vector = Union[List[BaseAtom], MutableSequence[BaseAtom], Sequence[BaseAtom], Collection[BaseAtom]]


class FiniteField:
    &#34;&#34;&#34;Represents a non-prime finite field&#34;&#34;&#34;
    def __init__(self,
                 prime: int,
                 dimension: int,
                 poly: Polynomial,
                 generator: Optional[Sequence[int]] = None,
                 root_symbol: Optional[str] = &#39;j&#39;):
        &#34;&#34;&#34;
        :param prime: the order of the prime field Fprime
        :param dimension: the dimension of the finite field seen as a vector space over its prime field
        :param poly: the minimal polynomial of the adjunct root j, must be irreducible over Fprime
        :param generator: an element of the field that generates the multiplicative group (tuple of int)
        :param root_symbol: for formatting elements
        &#34;&#34;&#34;
        self._prime_field = PrimeField(prime)
        self.dimension = dimension
        self.base_polynomial = poly
        self.generator = generator
        self.root_symbol = root_symbol

        assert self.dimension &gt;= 2
        assert self.base_polynomial.base_field == self.prime_field
        assert self.base_polynomial.degree == self.dimension
        assert self.base_polynomial.is_monic
        assert self.base_polynomial.is_irreducible

        self.root_powers = dict()
        self._compute_root_powers()

        self.generator_powers = dict()
        self.element_as_powers = dict()
        if self.generator is not None:
            self.generator = self.element(self.generator)
            self._check_generator_order()

        self._frobenius_map = self._compute_frobenius_map()

    def _compute_frobenius_map(self) -&gt; MutableSequence[&#39;FFElement&#39;]:
        &#34;&#34;&#34;The Frobenius automorphisme is defined by a -&gt; a^p where p is the prime field characteristic
        This methods computes the inverse map of the automorphisme&#34;&#34;&#34;
        p_th_roots = []
        for b in self.basis:
            for e in self:
                if e ** self.characteristic == b:
                    p_th_roots.append(e)
        return p_th_roots

    def element_order(self, e: &#39;FFElement&#39;) -&gt; int:
        &#34;&#34;&#34;Returns the order of an element, that is the minimal integer k such as e^k = 1&#34;&#34;&#34;
        if self.has_valid_generator:
            return self.generator_powers[e]
        else:
            max_order = self.order - 1  # the order of the multiplicative group
            order = 1
            g = e
            while g != self.one and order &lt; max_order:
                g *= e
                order += 1
            return order

    @property
    def frobenius_map(self) -&gt; MutableSequence[&#39;FFElement&#39;]:
        &#34;&#34;&#34;It&#39;s actually the linear map of the inverse function of Frobenius automorphism (see MISCELLANEOUS.md)&#34;&#34;&#34;
        return self._frobenius_map[:]

    def _check_generator_order(self):
        &#34;&#34;&#34;computes the powers of the wanna-be generator and checks
        if the results form the multiplicative group. This method can be
        computer-intensive for large finite fields&#34;&#34;&#34;
        expected_order = self.order - 1  # the order of the multiplicative group
        order = 1
        g = self.generator
        powers = dict()
        powers[order] = g

        while g != self.one and order &lt;= expected_order:
            g *= self.generator
            order += 1
            powers[order] = g

        if order != expected_order:
            raise ValueError(f&#39;Element {self.generator} is not a generator for {self}&#39;)
        else:
            self.generator_powers = powers

        if self.has_valid_generator:
            for (o, e) in self.generator_powers.items():
                if e != self.zero:
                    self.element_as_powers[e] = o  # reverse map

    @property
    def has_valid_generator(self) -&gt; bool:
        return len(self.generator_powers) &gt; 0 and self.generator is not None

    @property
    def prime_field(self) -&gt; PrimeField:
        return self._prime_field

    @property
    def basis(self) -&gt; Iterator[&#39;FFElement&#39;]:
        return (self(0, 1) ** e for e in range(0, self.dimension))

    def _compute_root_powers(self):
        p = self.base_polynomial
        f = self.prime_field
        pr = p - p.monic(p.degree)
        p_neutral = f.polynomial(f.one)
        r = -pr
        e = self.dimension
        self.root_powers[e] = r
        while r != p_neutral and e &lt; self.order - 1:
            r *= r.monic(1)
            e += 1
            if r.degree == p.degree:
                r -= p.monic(p.degree)
                r += -pr
            self.root_powers[e] = r

    def _safe_convert_vector(self, v: Vector) -&gt; List[PFElement]:

        if isinstance(v, FFElement):
            assert v.field == self
            o = v.vector[:]
        else:
            o = []
            if not isinstance(v, (list, tuple)):
                v = [v]

            for c in v:
                if isinstance(c, int):
                    o.append(self.prime_field(c))
                else:
                    assert isinstance(c, PFElement)
                    o.append(c)

            for _ in range(self.dimension - len(v)):
                o.append(self.prime_field.zero)

        return o

    @property
    def order(self) -&gt; int:
        &#34;&#34;&#34;
        :return: The order of the field
        &#34;&#34;&#34;
        return self.prime_field.characteristic ** self.dimension

    def element(self, v: Union[Vector, &#39;FFElement&#39;]) -&gt; &#39;FFElement&#39;:
        return FFElement(self, self._safe_convert_vector(v))

    @property
    def zero(self) -&gt; &#39;FFElement&#39;:
        return self.element([self.prime_field.zero] * self.dimension)

    @property
    def one(self) -&gt; &#39;FFElement&#39;:
        return self.element([self.prime_field.one] + [self.prime_field.zero] * (self.dimension - 1))

    @property
    def characteristic(self) -&gt; int:
        return self._prime_field.characteristic

    @property
    def null(self) -&gt; &#39;FFElement&#39;:
        return self.zero

    @property
    def neutral(self) -&gt; &#39;FFElement&#39;:
        return self.one

    def __call__(self, *args) -&gt; &#39;FFElement&#39;:
        return self.element([self.prime_field(c) for c in args])

    def __eq__(self, other: &#39;FiniteField&#39;) -&gt; bool:
        assert isinstance(other, self.__class__)
        return other.prime_field == self.prime_field and other.dimension == self.dimension

    def __iter__(self) -&gt; Iterator[&#39;FFElement&#39;]:
        &#34;&#34;&#34;
        Iterates over all the elements
        :return: an iterator
        &#34;&#34;&#34;
        iterables = [self.prime_field] * self.dimension
        return iter((self.element(list(v)) for v in cartesian_product(*iterables)))

    def __str__(self) -&gt; str:
        return f&#39;Finite field of order {self.prime_field.characteristic}^{self.dimension}&#39;

    def __repr__(self) -&gt; str:
        s = f&#39;{self.__class__.__name__}(&#39;
        s += f&#39;{self.prime_field.characteristic}, &#39;
        s += f&#39;{self.dimension}, &#39;
        s += f&#39;{repr(self.base_polynomial)}, &#39;
        if self.has_valid_generator:
            s += f&#39; generator={repr(self.generator.vector)})&#39;
        else:
            s += &#39;)&#39;
        return s

    def add(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        assert a.field == b.field == self
        s = [self.prime_field.zero] * self.dimension
        for i in range(0, self.dimension):
            s[i] = a[i] + b[i]
        return self.element(s)

    def additive_inverse(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        return self.element([-e for e in a.vector])

    def mul(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        assert a.field == b.field == self

        if self.has_valid_generator:

            if a.null or b.null:
                return self.null

            p1 = self.element_as_powers[a]
            p2 = self.element_as_powers[b]
            p = p1 + p2
            if p in self.generator_powers.keys():
                return self.generator_powers[p]
            else:
                assert p &gt; self.order - 1
                return self.generator_powers[p - self.order + 1]

        else:
            p1 = self.polynomial_from_element(a)
            p2 = self.polynomial_from_element(b)
            p = (p1 * p2) % self.base_polynomial

            return self.element_from_polynomial(p)

    def ext_mul(self, n: int, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        assert a.field == self
        r = self.zero
        for _ in range(0, n):
            r += a
        return r

    def pow(self, a: &#39;FFElement&#39;, e: int) -&gt; &#39;FFElement&#39;:
        assert a.field == self
        assert e &gt;= 0
        res = power(a, e)
        if not isinstance(res, FFElement):
            return self(res)
        else:
            return res

    def multiplicative_inverse(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:

        if self.has_valid_generator:
            p = self.element_as_powers[a]
            if self.order - 1 - p == 0:
                return self.generator_powers[self.order - 1]
            else:
                return self.generator_powers[self.order - 1 - p]
        else:
            p_a = self.polynomial_from_element(a)
            p = self.base_polynomial

            if p_a == p or p_a == p_a.null:
                raise ZeroDivisionError

            neutral = p_a.unit
            t = p_a.null
            newt = neutral
            r = p
            newr = p_a
            while newr != newr.null:
                quotient = r / newr
                r, newr = newr, r - quotient * newr
                t, newt = newt, t - quotient * newt

            assert r.degree == 0
            # if r.degree &gt; 0
            # Either p is not irreducible over the base_field or p_a is a multiple of p
            return self.element_from_polynomial((neutral / r) * t)

    def div(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        if b.null:
            raise ZeroDivisionError
        if a.null:
            return self.zero

        return a * self.multiplicative_inverse(b)

    def floor_div(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        return self.div(a, b)

    def mod(self, _, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        if b.null:
            raise ZeroDivisionError

        return self.zero

    def divmod(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; Tuple[&#39;FFElement&#39;, &#39;FFElement&#39;]:
        return self.div(a, b), self.mod(a, b)

    def format_element(self, e: &#39;FFElement&#39;, format_spec: str = &#39;&#39;) -&gt; str:

        if format_spec == &#39;short&#39;:
            s = &#39;&#39;
            if e.is_scalar:
                s = str(e.vector[0])
            else:
                for c in str(self.polynomial_from_element(e)):
                    if c != &#39; &#39;:
                        s += c
                return f&#39;({s})&#39;
        else:
            s = str(self.polynomial_from_element(e))
        return s

    def polynomial(self, *args, indeterminate: Optional[str] = &#39;X&#39;) -&gt; Polynomial:
        coefficients = []
        for c in args:
            if isinstance(c, (tuple, list)):
                coefficients.append(self.element(c))
            elif isinstance(c, FFElement):
                coefficients.append(c)
            else:
                # shall be an integer or, at least an atom (e.g. a PFElement)
                c = [c] + [self.prime_field.zero] * (self.dimension - 1)
                coefficients.append(self.element(c))

        return Polynomial(coefficients, base_field=self, indeterminate=indeterminate)

    def linear_polynomial(self, e: &#39;FFElement&#39;) -&gt; Polynomial:
        p = self.polynomial(-e)
        p += p.monic(1)
        return p

    def check_irreducible_polynomial(self, p: Polynomial) -&gt; bool:
        assert p.base_field == self
        return p.is_irreducible

    def frobenius_reciprocal(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:

        assert isinstance(a, FFElement)
        assert a in self
        r = self.zero
        for i, e in enumerate(a.vector):
            b = self._frobenius_map[i]
            r += self(e) * b
        return r

    def polynomial_from_element(self, e: &#39;FFElement&#39;) -&gt; Polynomial:
        return Polynomial(e.vector, self.prime_field, indeterminate=self.root_symbol)

    def element_from_polynomial(self, p: Polynomial) -&gt; &#39;FFElement&#39;:
        assert p.base_field == self.prime_field
        assert p.degree &lt;= self.dimension - 1
        v = p.coefficients
        if p.degree &lt; self.dimension - 1:
            v += [self.prime_field.zero] * (self.dimension - (1 + p.degree))
        return self.element(v)

    def find_generator(self, set_generator=False) -&gt; &#39;FFElement&#39;:

        if self.has_valid_generator:
            g = self.generator
        elif maybe_prime(self.order - 1):
            # if the order of the multiplicative group is prime, any element but 1 and -1 is a generator
            p = self.base_polynomial.monic(self.dimension - 1)
            p += self.base_polynomial.monic(0)
            g = self.element_from_polynomial(p)
        else:
            # find it the hard way
            g = None
            for elt in iter(self):
                if elt != self.one and elt != self.zero:
                    o = self.element_order(elt)
                    if o == self.order - 1:
                        g = elt
                        break
            if g is None:
                raise ValueError(f&#39;Unable to find a generator for {self}. Please check the field definition&#39;)
        if not self.has_valid_generator and set_generator:
            self.generator = g
            self._check_generator_order()
        return g

    def parse_poly(self, expr: str) -&gt; Polynomial:
        &#34;&#34;&#34;Returns a polynomial from its symbolic expression&#34;&#34;&#34;
        return symbolic_polynomial(expr, self)


class FFElement:
    def __init__(self, field: FiniteField, v: Vector):
        self.field = field
        self.vector = v

        assert isinstance(field, FiniteField)
        assert len(self.vector) == self.field.dimension

    @property
    def null(self) -&gt; bool:
        return self == self.field.zero

    @property
    def is_scalar(self) -&gt; bool:
        r = True
        for c in self.vector[1:]:
            if not c.is_zero:
                r = False
                break
        return r

    def __str__(self) -&gt; str:
        return self.field.format_element(self)

    def __format__(self, format_spec: str) -&gt; str:
        return self.field.format_element(self, format_spec)

    def __repr__(self) -&gt; str:
        s = f&#39;{self.__class__.__name__}(&#39;
        s += f&#39;{repr(self.field)}, &#39;
        s += str(self.vector)
        s += &#39;)&#39;
        return s

    def __getitem__(self, item: int) -&gt; PFElement:
        return self.vector[item]

    def __add__(self, other: Any) -&gt; &#39;FFElement&#39;:
        if isinstance(other, self.__class__):
            return self.field.add(self, other)
        elif isinstance(other, PFElement):
            return self.field.add(self, self.field(other))
        elif isinstance(other, int):
            return self.field.add(self, self.field(other))
        else:
            return operator.add(other, self)

    def __eq__(self, other: Any) -&gt; bool:
        if isinstance(other, int):
            other = self.field(self.field.prime_field(other))

        elif isinstance(other, PFElement):
            assert other.field == self.field.prime_field
            other = self.field(other)

        for i in range(0, self.field.dimension):
            if other[i] != self[i]:
                return False
        return True

    def __neg__(self) -&gt; &#39;FFElement&#39;:
        return self.field.additive_inverse(self)

    def __sub__(self, other: Any) -&gt; &#39;FFElement&#39;:
        return self.__add__(-other)

    def __mul__(self, other: Any) -&gt; &#39;FFElement&#39;:
        if isinstance(other, FFElement):
            return self.field.mul(self, other)
        elif isinstance(other, int):
            return self.field.ext_mul(other, self)
        elif isinstance(other, PFElement):
            return self.field.mul(self, self.field(other))
        else:
            return operator.add(other, self)

    def __rmul__(self, other: Any) -&gt; &#39;FFElement&#39;:
        return self.__mul__(other)

    def __pow__(self, e: int, modulo=None) -&gt; &#39;FFElement&#39;:
        return self.field.pow(self, e)

    def __truediv__(self, other: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        if isinstance(other, FFElement):
            return self.field.div(self, other)
        elif isinstance(other, (int, PFElement)):
            return self.field.mul(self, self.field(other))

    def __floordiv__(self, other: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        return self.__truediv__(other)

    def __mod__(self, other: Any) -&gt; &#39;FFElement&#39;:
        return self.field.zero

    def __hash__(self) -&gt; int:
        return hash(tuple(self.vector))

    def __len__(self) -&gt; int:
        return len(self.vector)

    def __invert__(self) -&gt; &#39;FFElement&#39;:
        return self.field.frobenius_reciprocal(self)


# Pre-computed finite fields
class Record:

    def __init__(self, code: str):
        self.code = code
        self.instance = None
        self.instantiated = False

    def instantiate(self):
        if not self.instantiated:
            self.instance = eval(self.code)
            self.instantiated = True

        return self.instance


FINITE_FIELD = {
    &#39;F2&#39;: Record(&#34;PrimeField(2)&#34;),
    &#39;F3&#39;: Record(&#34;PrimeField(3)&#34;),
    &#39;F4&#39;: Record(&#34;FiniteField(2, 2, symbolic_polynomial(&#39;X^2+X+1&#39;, PrimeField(2)), generator=(0, 1))&#34;),
    &#39;F5&#39;: Record(&#34;PrimeField(5)&#34;),
    &#39;F7&#39;: Record(&#34;PrimeField(7)&#34;),
    &#39;F8&#39;: Record(&#34;FiniteField(2, 3, symbolic_polynomial(&#39;X^3+X+1&#39;, PrimeField(2)), generator=(0, 1))&#34;),
    &#39;F9&#39;: Record(&#34;FiniteField(3, 2, symbolic_polynomial(&#39;X^2+1&#39;, PrimeField(3)), generator=(1, 1))&#34;),
    &#39;F11&#39;: Record(&#34;PrimeField(11)&#34;),
    &#39;F13&#39;: Record(&#34;PrimeField(13)&#34;),
    &#39;F16&#39;: Record(&#34;FiniteField(2, 4, symbolic_polynomial(&#39;X^4+X+1&#39;, PrimeField(2)), generator=(1, 1, 0, 0))&#34;),
    &#39;F17&#39;: Record(&#34;PrimeField(17)&#34;),
    &#39;F19&#39;: Record(&#34;PrimeField(19)&#34;),
    &#39;F23&#39;: Record(&#34;PrimeField(23)&#34;),
    &#39;F25&#39;: Record(&#34;FiniteField(5, 2, symbolic_polynomial(&#39;X^2+2&#39;, PrimeField(5)), generator=(1, 1))&#34;),
    &#39;F27&#39;: Record(&#34;FiniteField(3, 3, symbolic_polynomial(&#39;X^3-X-1&#39;, PrimeField(3)), generator=(1, 0, 1))&#34;)
}


def finite_field(order):
    if f&#39;F{order}&#39; in FINITE_FIELD:
        return FINITE_FIELD[f&#39;F{order}&#39;].instantiate()
    else:
        raise ValueError(f&#39;No pre-instantiated finite field of order {order}&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyimath.finitefield.finite_field"><code class="name flex">
<span>def <span class="ident">finite_field</span></span>(<span>order)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finite_field(order):
    if f&#39;F{order}&#39; in FINITE_FIELD:
        return FINITE_FIELD[f&#39;F{order}&#39;].instantiate()
    else:
        raise ValueError(f&#39;No pre-instantiated finite field of order {order}&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyimath.finitefield.FFElement"><code class="flex name class">
<span>class <span class="ident">FFElement</span></span>
<span>(</span><span>field, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FFElement:
    def __init__(self, field: FiniteField, v: Vector):
        self.field = field
        self.vector = v

        assert isinstance(field, FiniteField)
        assert len(self.vector) == self.field.dimension

    @property
    def null(self) -&gt; bool:
        return self == self.field.zero

    @property
    def is_scalar(self) -&gt; bool:
        r = True
        for c in self.vector[1:]:
            if not c.is_zero:
                r = False
                break
        return r

    def __str__(self) -&gt; str:
        return self.field.format_element(self)

    def __format__(self, format_spec: str) -&gt; str:
        return self.field.format_element(self, format_spec)

    def __repr__(self) -&gt; str:
        s = f&#39;{self.__class__.__name__}(&#39;
        s += f&#39;{repr(self.field)}, &#39;
        s += str(self.vector)
        s += &#39;)&#39;
        return s

    def __getitem__(self, item: int) -&gt; PFElement:
        return self.vector[item]

    def __add__(self, other: Any) -&gt; &#39;FFElement&#39;:
        if isinstance(other, self.__class__):
            return self.field.add(self, other)
        elif isinstance(other, PFElement):
            return self.field.add(self, self.field(other))
        elif isinstance(other, int):
            return self.field.add(self, self.field(other))
        else:
            return operator.add(other, self)

    def __eq__(self, other: Any) -&gt; bool:
        if isinstance(other, int):
            other = self.field(self.field.prime_field(other))

        elif isinstance(other, PFElement):
            assert other.field == self.field.prime_field
            other = self.field(other)

        for i in range(0, self.field.dimension):
            if other[i] != self[i]:
                return False
        return True

    def __neg__(self) -&gt; &#39;FFElement&#39;:
        return self.field.additive_inverse(self)

    def __sub__(self, other: Any) -&gt; &#39;FFElement&#39;:
        return self.__add__(-other)

    def __mul__(self, other: Any) -&gt; &#39;FFElement&#39;:
        if isinstance(other, FFElement):
            return self.field.mul(self, other)
        elif isinstance(other, int):
            return self.field.ext_mul(other, self)
        elif isinstance(other, PFElement):
            return self.field.mul(self, self.field(other))
        else:
            return operator.add(other, self)

    def __rmul__(self, other: Any) -&gt; &#39;FFElement&#39;:
        return self.__mul__(other)

    def __pow__(self, e: int, modulo=None) -&gt; &#39;FFElement&#39;:
        return self.field.pow(self, e)

    def __truediv__(self, other: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        if isinstance(other, FFElement):
            return self.field.div(self, other)
        elif isinstance(other, (int, PFElement)):
            return self.field.mul(self, self.field(other))

    def __floordiv__(self, other: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        return self.__truediv__(other)

    def __mod__(self, other: Any) -&gt; &#39;FFElement&#39;:
        return self.field.zero

    def __hash__(self) -&gt; int:
        return hash(tuple(self.vector))

    def __len__(self) -&gt; int:
        return len(self.vector)

    def __invert__(self) -&gt; &#39;FFElement&#39;:
        return self.field.frobenius_reciprocal(self)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyimath.finitefield.FFElement.is_scalar"><code class="name">var <span class="ident">is_scalar</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_scalar(self) -&gt; bool:
    r = True
    for c in self.vector[1:]:
        if not c.is_zero:
            r = False
            break
    return r</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FFElement.null"><code class="name">var <span class="ident">null</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def null(self) -&gt; bool:
    return self == self.field.zero</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyimath.finitefield.FiniteField"><code class="flex name class">
<span>class <span class="ident">FiniteField</span></span>
<span>(</span><span>prime, dimension, poly, generator=None, root_symbol='j')</span>
</code></dt>
<dd>
<section class="desc"><p>Represents a non-prime finite field</p>
<p>:param prime: the order of the prime field Fprime
:param dimension: the dimension of the finite field seen as a vector space over its prime field
:param poly: the minimal polynomial of the adjunct root j, must be irreducible over Fprime
:param generator: an element of the field that generates the multiplicative group (tuple of int)
:param root_symbol: for formatting elements</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FiniteField:
    &#34;&#34;&#34;Represents a non-prime finite field&#34;&#34;&#34;
    def __init__(self,
                 prime: int,
                 dimension: int,
                 poly: Polynomial,
                 generator: Optional[Sequence[int]] = None,
                 root_symbol: Optional[str] = &#39;j&#39;):
        &#34;&#34;&#34;
        :param prime: the order of the prime field Fprime
        :param dimension: the dimension of the finite field seen as a vector space over its prime field
        :param poly: the minimal polynomial of the adjunct root j, must be irreducible over Fprime
        :param generator: an element of the field that generates the multiplicative group (tuple of int)
        :param root_symbol: for formatting elements
        &#34;&#34;&#34;
        self._prime_field = PrimeField(prime)
        self.dimension = dimension
        self.base_polynomial = poly
        self.generator = generator
        self.root_symbol = root_symbol

        assert self.dimension &gt;= 2
        assert self.base_polynomial.base_field == self.prime_field
        assert self.base_polynomial.degree == self.dimension
        assert self.base_polynomial.is_monic
        assert self.base_polynomial.is_irreducible

        self.root_powers = dict()
        self._compute_root_powers()

        self.generator_powers = dict()
        self.element_as_powers = dict()
        if self.generator is not None:
            self.generator = self.element(self.generator)
            self._check_generator_order()

        self._frobenius_map = self._compute_frobenius_map()

    def _compute_frobenius_map(self) -&gt; MutableSequence[&#39;FFElement&#39;]:
        &#34;&#34;&#34;The Frobenius automorphisme is defined by a -&gt; a^p where p is the prime field characteristic
        This methods computes the inverse map of the automorphisme&#34;&#34;&#34;
        p_th_roots = []
        for b in self.basis:
            for e in self:
                if e ** self.characteristic == b:
                    p_th_roots.append(e)
        return p_th_roots

    def element_order(self, e: &#39;FFElement&#39;) -&gt; int:
        &#34;&#34;&#34;Returns the order of an element, that is the minimal integer k such as e^k = 1&#34;&#34;&#34;
        if self.has_valid_generator:
            return self.generator_powers[e]
        else:
            max_order = self.order - 1  # the order of the multiplicative group
            order = 1
            g = e
            while g != self.one and order &lt; max_order:
                g *= e
                order += 1
            return order

    @property
    def frobenius_map(self) -&gt; MutableSequence[&#39;FFElement&#39;]:
        &#34;&#34;&#34;It&#39;s actually the linear map of the inverse function of Frobenius automorphism (see MISCELLANEOUS.md)&#34;&#34;&#34;
        return self._frobenius_map[:]

    def _check_generator_order(self):
        &#34;&#34;&#34;computes the powers of the wanna-be generator and checks
        if the results form the multiplicative group. This method can be
        computer-intensive for large finite fields&#34;&#34;&#34;
        expected_order = self.order - 1  # the order of the multiplicative group
        order = 1
        g = self.generator
        powers = dict()
        powers[order] = g

        while g != self.one and order &lt;= expected_order:
            g *= self.generator
            order += 1
            powers[order] = g

        if order != expected_order:
            raise ValueError(f&#39;Element {self.generator} is not a generator for {self}&#39;)
        else:
            self.generator_powers = powers

        if self.has_valid_generator:
            for (o, e) in self.generator_powers.items():
                if e != self.zero:
                    self.element_as_powers[e] = o  # reverse map

    @property
    def has_valid_generator(self) -&gt; bool:
        return len(self.generator_powers) &gt; 0 and self.generator is not None

    @property
    def prime_field(self) -&gt; PrimeField:
        return self._prime_field

    @property
    def basis(self) -&gt; Iterator[&#39;FFElement&#39;]:
        return (self(0, 1) ** e for e in range(0, self.dimension))

    def _compute_root_powers(self):
        p = self.base_polynomial
        f = self.prime_field
        pr = p - p.monic(p.degree)
        p_neutral = f.polynomial(f.one)
        r = -pr
        e = self.dimension
        self.root_powers[e] = r
        while r != p_neutral and e &lt; self.order - 1:
            r *= r.monic(1)
            e += 1
            if r.degree == p.degree:
                r -= p.monic(p.degree)
                r += -pr
            self.root_powers[e] = r

    def _safe_convert_vector(self, v: Vector) -&gt; List[PFElement]:

        if isinstance(v, FFElement):
            assert v.field == self
            o = v.vector[:]
        else:
            o = []
            if not isinstance(v, (list, tuple)):
                v = [v]

            for c in v:
                if isinstance(c, int):
                    o.append(self.prime_field(c))
                else:
                    assert isinstance(c, PFElement)
                    o.append(c)

            for _ in range(self.dimension - len(v)):
                o.append(self.prime_field.zero)

        return o

    @property
    def order(self) -&gt; int:
        &#34;&#34;&#34;
        :return: The order of the field
        &#34;&#34;&#34;
        return self.prime_field.characteristic ** self.dimension

    def element(self, v: Union[Vector, &#39;FFElement&#39;]) -&gt; &#39;FFElement&#39;:
        return FFElement(self, self._safe_convert_vector(v))

    @property
    def zero(self) -&gt; &#39;FFElement&#39;:
        return self.element([self.prime_field.zero] * self.dimension)

    @property
    def one(self) -&gt; &#39;FFElement&#39;:
        return self.element([self.prime_field.one] + [self.prime_field.zero] * (self.dimension - 1))

    @property
    def characteristic(self) -&gt; int:
        return self._prime_field.characteristic

    @property
    def null(self) -&gt; &#39;FFElement&#39;:
        return self.zero

    @property
    def neutral(self) -&gt; &#39;FFElement&#39;:
        return self.one

    def __call__(self, *args) -&gt; &#39;FFElement&#39;:
        return self.element([self.prime_field(c) for c in args])

    def __eq__(self, other: &#39;FiniteField&#39;) -&gt; bool:
        assert isinstance(other, self.__class__)
        return other.prime_field == self.prime_field and other.dimension == self.dimension

    def __iter__(self) -&gt; Iterator[&#39;FFElement&#39;]:
        &#34;&#34;&#34;
        Iterates over all the elements
        :return: an iterator
        &#34;&#34;&#34;
        iterables = [self.prime_field] * self.dimension
        return iter((self.element(list(v)) for v in cartesian_product(*iterables)))

    def __str__(self) -&gt; str:
        return f&#39;Finite field of order {self.prime_field.characteristic}^{self.dimension}&#39;

    def __repr__(self) -&gt; str:
        s = f&#39;{self.__class__.__name__}(&#39;
        s += f&#39;{self.prime_field.characteristic}, &#39;
        s += f&#39;{self.dimension}, &#39;
        s += f&#39;{repr(self.base_polynomial)}, &#39;
        if self.has_valid_generator:
            s += f&#39; generator={repr(self.generator.vector)})&#39;
        else:
            s += &#39;)&#39;
        return s

    def add(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        assert a.field == b.field == self
        s = [self.prime_field.zero] * self.dimension
        for i in range(0, self.dimension):
            s[i] = a[i] + b[i]
        return self.element(s)

    def additive_inverse(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        return self.element([-e for e in a.vector])

    def mul(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        assert a.field == b.field == self

        if self.has_valid_generator:

            if a.null or b.null:
                return self.null

            p1 = self.element_as_powers[a]
            p2 = self.element_as_powers[b]
            p = p1 + p2
            if p in self.generator_powers.keys():
                return self.generator_powers[p]
            else:
                assert p &gt; self.order - 1
                return self.generator_powers[p - self.order + 1]

        else:
            p1 = self.polynomial_from_element(a)
            p2 = self.polynomial_from_element(b)
            p = (p1 * p2) % self.base_polynomial

            return self.element_from_polynomial(p)

    def ext_mul(self, n: int, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        assert a.field == self
        r = self.zero
        for _ in range(0, n):
            r += a
        return r

    def pow(self, a: &#39;FFElement&#39;, e: int) -&gt; &#39;FFElement&#39;:
        assert a.field == self
        assert e &gt;= 0
        res = power(a, e)
        if not isinstance(res, FFElement):
            return self(res)
        else:
            return res

    def multiplicative_inverse(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:

        if self.has_valid_generator:
            p = self.element_as_powers[a]
            if self.order - 1 - p == 0:
                return self.generator_powers[self.order - 1]
            else:
                return self.generator_powers[self.order - 1 - p]
        else:
            p_a = self.polynomial_from_element(a)
            p = self.base_polynomial

            if p_a == p or p_a == p_a.null:
                raise ZeroDivisionError

            neutral = p_a.unit
            t = p_a.null
            newt = neutral
            r = p
            newr = p_a
            while newr != newr.null:
                quotient = r / newr
                r, newr = newr, r - quotient * newr
                t, newt = newt, t - quotient * newt

            assert r.degree == 0
            # if r.degree &gt; 0
            # Either p is not irreducible over the base_field or p_a is a multiple of p
            return self.element_from_polynomial((neutral / r) * t)

    def div(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        if b.null:
            raise ZeroDivisionError
        if a.null:
            return self.zero

        return a * self.multiplicative_inverse(b)

    def floor_div(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        return self.div(a, b)

    def mod(self, _, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
        if b.null:
            raise ZeroDivisionError

        return self.zero

    def divmod(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; Tuple[&#39;FFElement&#39;, &#39;FFElement&#39;]:
        return self.div(a, b), self.mod(a, b)

    def format_element(self, e: &#39;FFElement&#39;, format_spec: str = &#39;&#39;) -&gt; str:

        if format_spec == &#39;short&#39;:
            s = &#39;&#39;
            if e.is_scalar:
                s = str(e.vector[0])
            else:
                for c in str(self.polynomial_from_element(e)):
                    if c != &#39; &#39;:
                        s += c
                return f&#39;({s})&#39;
        else:
            s = str(self.polynomial_from_element(e))
        return s

    def polynomial(self, *args, indeterminate: Optional[str] = &#39;X&#39;) -&gt; Polynomial:
        coefficients = []
        for c in args:
            if isinstance(c, (tuple, list)):
                coefficients.append(self.element(c))
            elif isinstance(c, FFElement):
                coefficients.append(c)
            else:
                # shall be an integer or, at least an atom (e.g. a PFElement)
                c = [c] + [self.prime_field.zero] * (self.dimension - 1)
                coefficients.append(self.element(c))

        return Polynomial(coefficients, base_field=self, indeterminate=indeterminate)

    def linear_polynomial(self, e: &#39;FFElement&#39;) -&gt; Polynomial:
        p = self.polynomial(-e)
        p += p.monic(1)
        return p

    def check_irreducible_polynomial(self, p: Polynomial) -&gt; bool:
        assert p.base_field == self
        return p.is_irreducible

    def frobenius_reciprocal(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:

        assert isinstance(a, FFElement)
        assert a in self
        r = self.zero
        for i, e in enumerate(a.vector):
            b = self._frobenius_map[i]
            r += self(e) * b
        return r

    def polynomial_from_element(self, e: &#39;FFElement&#39;) -&gt; Polynomial:
        return Polynomial(e.vector, self.prime_field, indeterminate=self.root_symbol)

    def element_from_polynomial(self, p: Polynomial) -&gt; &#39;FFElement&#39;:
        assert p.base_field == self.prime_field
        assert p.degree &lt;= self.dimension - 1
        v = p.coefficients
        if p.degree &lt; self.dimension - 1:
            v += [self.prime_field.zero] * (self.dimension - (1 + p.degree))
        return self.element(v)

    def find_generator(self, set_generator=False) -&gt; &#39;FFElement&#39;:

        if self.has_valid_generator:
            g = self.generator
        elif maybe_prime(self.order - 1):
            # if the order of the multiplicative group is prime, any element but 1 and -1 is a generator
            p = self.base_polynomial.monic(self.dimension - 1)
            p += self.base_polynomial.monic(0)
            g = self.element_from_polynomial(p)
        else:
            # find it the hard way
            g = None
            for elt in iter(self):
                if elt != self.one and elt != self.zero:
                    o = self.element_order(elt)
                    if o == self.order - 1:
                        g = elt
                        break
            if g is None:
                raise ValueError(f&#39;Unable to find a generator for {self}. Please check the field definition&#39;)
        if not self.has_valid_generator and set_generator:
            self.generator = g
            self._check_generator_order()
        return g

    def parse_poly(self, expr: str) -&gt; Polynomial:
        &#34;&#34;&#34;Returns a polynomial from its symbolic expression&#34;&#34;&#34;
        return symbolic_polynomial(expr, self)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyimath.finitefield.FiniteField.basis"><code class="name">var <span class="ident">basis</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def basis(self) -&gt; Iterator[&#39;FFElement&#39;]:
    return (self(0, 1) ** e for e in range(0, self.dimension))</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.characteristic"><code class="name">var <span class="ident">characteristic</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def characteristic(self) -&gt; int:
    return self._prime_field.characteristic</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.frobenius_map"><code class="name">var <span class="ident">frobenius_map</span></code></dt>
<dd>
<section class="desc"><p>It's actually the linear map of the inverse function of Frobenius automorphism (see MISCELLANEOUS.md)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frobenius_map(self) -&gt; MutableSequence[&#39;FFElement&#39;]:
    &#34;&#34;&#34;It&#39;s actually the linear map of the inverse function of Frobenius automorphism (see MISCELLANEOUS.md)&#34;&#34;&#34;
    return self._frobenius_map[:]</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.has_valid_generator"><code class="name">var <span class="ident">has_valid_generator</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_valid_generator(self) -&gt; bool:
    return len(self.generator_powers) &gt; 0 and self.generator is not None</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.neutral"><code class="name">var <span class="ident">neutral</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def neutral(self) -&gt; &#39;FFElement&#39;:
    return self.one</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.null"><code class="name">var <span class="ident">null</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def null(self) -&gt; &#39;FFElement&#39;:
    return self.zero</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.one"><code class="name">var <span class="ident">one</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def one(self) -&gt; &#39;FFElement&#39;:
    return self.element([self.prime_field.one] + [self.prime_field.zero] * (self.dimension - 1))</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.order"><code class="name">var <span class="ident">order</span></code></dt>
<dd>
<section class="desc"><p>:return: The order of the field</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def order(self) -&gt; int:
    &#34;&#34;&#34;
    :return: The order of the field
    &#34;&#34;&#34;
    return self.prime_field.characteristic ** self.dimension</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.prime_field"><code class="name">var <span class="ident">prime_field</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def prime_field(self) -&gt; PrimeField:
    return self._prime_field</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.zero"><code class="name">var <span class="ident">zero</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zero(self) -&gt; &#39;FFElement&#39;:
    return self.element([self.prime_field.zero] * self.dimension)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyimath.finitefield.FiniteField.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    assert a.field == b.field == self
    s = [self.prime_field.zero] * self.dimension
    for i in range(0, self.dimension):
        s[i] = a[i] + b[i]
    return self.element(s)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.additive_inverse"><code class="name flex">
<span>def <span class="ident">additive_inverse</span></span>(<span>self, a)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def additive_inverse(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    return self.element([-e for e in a.vector])</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.check_irreducible_polynomial"><code class="name flex">
<span>def <span class="ident">check_irreducible_polynomial</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_irreducible_polynomial(self, p: Polynomial) -&gt; bool:
    assert p.base_field == self
    return p.is_irreducible</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.div"><code class="name flex">
<span>def <span class="ident">div</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def div(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    if b.null:
        raise ZeroDivisionError
    if a.null:
        return self.zero

    return a * self.multiplicative_inverse(b)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.divmod"><code class="name flex">
<span>def <span class="ident">divmod</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divmod(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; Tuple[&#39;FFElement&#39;, &#39;FFElement&#39;]:
    return self.div(a, b), self.mod(a, b)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.element"><code class="name flex">
<span>def <span class="ident">element</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def element(self, v: Union[Vector, &#39;FFElement&#39;]) -&gt; &#39;FFElement&#39;:
    return FFElement(self, self._safe_convert_vector(v))</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.element_from_polynomial"><code class="name flex">
<span>def <span class="ident">element_from_polynomial</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def element_from_polynomial(self, p: Polynomial) -&gt; &#39;FFElement&#39;:
    assert p.base_field == self.prime_field
    assert p.degree &lt;= self.dimension - 1
    v = p.coefficients
    if p.degree &lt; self.dimension - 1:
        v += [self.prime_field.zero] * (self.dimension - (1 + p.degree))
    return self.element(v)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.element_order"><code class="name flex">
<span>def <span class="ident">element_order</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the order of an element, that is the minimal integer k such as e^k = 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def element_order(self, e: &#39;FFElement&#39;) -&gt; int:
    &#34;&#34;&#34;Returns the order of an element, that is the minimal integer k such as e^k = 1&#34;&#34;&#34;
    if self.has_valid_generator:
        return self.generator_powers[e]
    else:
        max_order = self.order - 1  # the order of the multiplicative group
        order = 1
        g = e
        while g != self.one and order &lt; max_order:
            g *= e
            order += 1
        return order</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.ext_mul"><code class="name flex">
<span>def <span class="ident">ext_mul</span></span>(<span>self, n, a)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ext_mul(self, n: int, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    assert a.field == self
    r = self.zero
    for _ in range(0, n):
        r += a
    return r</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.find_generator"><code class="name flex">
<span>def <span class="ident">find_generator</span></span>(<span>self, set_generator=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_generator(self, set_generator=False) -&gt; &#39;FFElement&#39;:

    if self.has_valid_generator:
        g = self.generator
    elif maybe_prime(self.order - 1):
        # if the order of the multiplicative group is prime, any element but 1 and -1 is a generator
        p = self.base_polynomial.monic(self.dimension - 1)
        p += self.base_polynomial.monic(0)
        g = self.element_from_polynomial(p)
    else:
        # find it the hard way
        g = None
        for elt in iter(self):
            if elt != self.one and elt != self.zero:
                o = self.element_order(elt)
                if o == self.order - 1:
                    g = elt
                    break
        if g is None:
            raise ValueError(f&#39;Unable to find a generator for {self}. Please check the field definition&#39;)
    if not self.has_valid_generator and set_generator:
        self.generator = g
        self._check_generator_order()
    return g</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.floor_div"><code class="name flex">
<span>def <span class="ident">floor_div</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def floor_div(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    return self.div(a, b)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.format_element"><code class="name flex">
<span>def <span class="ident">format_element</span></span>(<span>self, e, format_spec='')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_element(self, e: &#39;FFElement&#39;, format_spec: str = &#39;&#39;) -&gt; str:

    if format_spec == &#39;short&#39;:
        s = &#39;&#39;
        if e.is_scalar:
            s = str(e.vector[0])
        else:
            for c in str(self.polynomial_from_element(e)):
                if c != &#39; &#39;:
                    s += c
            return f&#39;({s})&#39;
    else:
        s = str(self.polynomial_from_element(e))
    return s</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.frobenius_reciprocal"><code class="name flex">
<span>def <span class="ident">frobenius_reciprocal</span></span>(<span>self, a)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frobenius_reciprocal(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:

    assert isinstance(a, FFElement)
    assert a in self
    r = self.zero
    for i, e in enumerate(a.vector):
        b = self._frobenius_map[i]
        r += self(e) * b
    return r</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.linear_polynomial"><code class="name flex">
<span>def <span class="ident">linear_polynomial</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linear_polynomial(self, e: &#39;FFElement&#39;) -&gt; Polynomial:
    p = self.polynomial(-e)
    p += p.monic(1)
    return p</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.mod"><code class="name flex">
<span>def <span class="ident">mod</span></span>(<span>self, _, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod(self, _, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    if b.null:
        raise ZeroDivisionError

    return self.zero</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.mul"><code class="name flex">
<span>def <span class="ident">mul</span></span>(<span>self, a, b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mul(self, a: &#39;FFElement&#39;, b: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:
    assert a.field == b.field == self

    if self.has_valid_generator:

        if a.null or b.null:
            return self.null

        p1 = self.element_as_powers[a]
        p2 = self.element_as_powers[b]
        p = p1 + p2
        if p in self.generator_powers.keys():
            return self.generator_powers[p]
        else:
            assert p &gt; self.order - 1
            return self.generator_powers[p - self.order + 1]

    else:
        p1 = self.polynomial_from_element(a)
        p2 = self.polynomial_from_element(b)
        p = (p1 * p2) % self.base_polynomial

        return self.element_from_polynomial(p)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.multiplicative_inverse"><code class="name flex">
<span>def <span class="ident">multiplicative_inverse</span></span>(<span>self, a)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiplicative_inverse(self, a: &#39;FFElement&#39;) -&gt; &#39;FFElement&#39;:

    if self.has_valid_generator:
        p = self.element_as_powers[a]
        if self.order - 1 - p == 0:
            return self.generator_powers[self.order - 1]
        else:
            return self.generator_powers[self.order - 1 - p]
    else:
        p_a = self.polynomial_from_element(a)
        p = self.base_polynomial

        if p_a == p or p_a == p_a.null:
            raise ZeroDivisionError

        neutral = p_a.unit
        t = p_a.null
        newt = neutral
        r = p
        newr = p_a
        while newr != newr.null:
            quotient = r / newr
            r, newr = newr, r - quotient * newr
            t, newt = newt, t - quotient * newt

        assert r.degree == 0
        # if r.degree &gt; 0
        # Either p is not irreducible over the base_field or p_a is a multiple of p
        return self.element_from_polynomial((neutral / r) * t)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.parse_poly"><code class="name flex">
<span>def <span class="ident">parse_poly</span></span>(<span>self, expr)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a polynomial from its symbolic expression</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_poly(self, expr: str) -&gt; Polynomial:
    &#34;&#34;&#34;Returns a polynomial from its symbolic expression&#34;&#34;&#34;
    return symbolic_polynomial(expr, self)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.polynomial"><code class="name flex">
<span>def <span class="ident">polynomial</span></span>(<span>self, *args, indeterminate='X')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polynomial(self, *args, indeterminate: Optional[str] = &#39;X&#39;) -&gt; Polynomial:
    coefficients = []
    for c in args:
        if isinstance(c, (tuple, list)):
            coefficients.append(self.element(c))
        elif isinstance(c, FFElement):
            coefficients.append(c)
        else:
            # shall be an integer or, at least an atom (e.g. a PFElement)
            c = [c] + [self.prime_field.zero] * (self.dimension - 1)
            coefficients.append(self.element(c))

    return Polynomial(coefficients, base_field=self, indeterminate=indeterminate)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.polynomial_from_element"><code class="name flex">
<span>def <span class="ident">polynomial_from_element</span></span>(<span>self, e)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polynomial_from_element(self, e: &#39;FFElement&#39;) -&gt; Polynomial:
    return Polynomial(e.vector, self.prime_field, indeterminate=self.root_symbol)</code></pre>
</details>
</dd>
<dt id="pyimath.finitefield.FiniteField.pow"><code class="name flex">
<span>def <span class="ident">pow</span></span>(<span>self, a, e)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pow(self, a: &#39;FFElement&#39;, e: int) -&gt; &#39;FFElement&#39;:
    assert a.field == self
    assert e &gt;= 0
    res = power(a, e)
    if not isinstance(res, FFElement):
        return self(res)
    else:
        return res</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyimath" href="index.html">pyimath</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyimath.finitefield.finite_field" href="#pyimath.finitefield.finite_field">finite_field</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyimath.finitefield.FFElement" href="#pyimath.finitefield.FFElement">FFElement</a></code></h4>
<ul class="">
<li><code><a title="pyimath.finitefield.FFElement.is_scalar" href="#pyimath.finitefield.FFElement.is_scalar">is_scalar</a></code></li>
<li><code><a title="pyimath.finitefield.FFElement.null" href="#pyimath.finitefield.FFElement.null">null</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyimath.finitefield.FiniteField" href="#pyimath.finitefield.FiniteField">FiniteField</a></code></h4>
<ul class="">
<li><code><a title="pyimath.finitefield.FiniteField.add" href="#pyimath.finitefield.FiniteField.add">add</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.additive_inverse" href="#pyimath.finitefield.FiniteField.additive_inverse">additive_inverse</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.basis" href="#pyimath.finitefield.FiniteField.basis">basis</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.characteristic" href="#pyimath.finitefield.FiniteField.characteristic">characteristic</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.check_irreducible_polynomial" href="#pyimath.finitefield.FiniteField.check_irreducible_polynomial">check_irreducible_polynomial</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.div" href="#pyimath.finitefield.FiniteField.div">div</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.divmod" href="#pyimath.finitefield.FiniteField.divmod">divmod</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.element" href="#pyimath.finitefield.FiniteField.element">element</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.element_from_polynomial" href="#pyimath.finitefield.FiniteField.element_from_polynomial">element_from_polynomial</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.element_order" href="#pyimath.finitefield.FiniteField.element_order">element_order</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.ext_mul" href="#pyimath.finitefield.FiniteField.ext_mul">ext_mul</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.find_generator" href="#pyimath.finitefield.FiniteField.find_generator">find_generator</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.floor_div" href="#pyimath.finitefield.FiniteField.floor_div">floor_div</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.format_element" href="#pyimath.finitefield.FiniteField.format_element">format_element</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.frobenius_map" href="#pyimath.finitefield.FiniteField.frobenius_map">frobenius_map</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.frobenius_reciprocal" href="#pyimath.finitefield.FiniteField.frobenius_reciprocal">frobenius_reciprocal</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.has_valid_generator" href="#pyimath.finitefield.FiniteField.has_valid_generator">has_valid_generator</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.linear_polynomial" href="#pyimath.finitefield.FiniteField.linear_polynomial">linear_polynomial</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.mod" href="#pyimath.finitefield.FiniteField.mod">mod</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.mul" href="#pyimath.finitefield.FiniteField.mul">mul</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.multiplicative_inverse" href="#pyimath.finitefield.FiniteField.multiplicative_inverse">multiplicative_inverse</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.neutral" href="#pyimath.finitefield.FiniteField.neutral">neutral</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.null" href="#pyimath.finitefield.FiniteField.null">null</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.one" href="#pyimath.finitefield.FiniteField.one">one</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.order" href="#pyimath.finitefield.FiniteField.order">order</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.parse_poly" href="#pyimath.finitefield.FiniteField.parse_poly">parse_poly</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.polynomial" href="#pyimath.finitefield.FiniteField.polynomial">polynomial</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.polynomial_from_element" href="#pyimath.finitefield.FiniteField.polynomial_from_element">polynomial_from_element</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.pow" href="#pyimath.finitefield.FiniteField.pow">pow</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.prime_field" href="#pyimath.finitefield.FiniteField.prime_field">prime_field</a></code></li>
<li><code><a title="pyimath.finitefield.FiniteField.zero" href="#pyimath.finitefield.FiniteField.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>